// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: account.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Nym_Vpn_AccountError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_AccountError.AccountErrorType = .storeAccountErrorUnspecified

  /// Detailed error message for logging and debugging
  var message: String = String()

  /// Optional additional details
  var details: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum AccountErrorType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case storeAccountErrorUnspecified // = 0

    /// The provided mnemonic was not able to be parsed
    case invalidMnemonic // = 1

    /// General error from the storage backend
    case storage // = 2

    /// Unable to proceed while connected
    case isConnected // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .storeAccountErrorUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .storeAccountErrorUnspecified
      case 1: self = .invalidMnemonic
      case 2: self = .storage
      case 3: self = .isConnected
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .storeAccountErrorUnspecified: return 0
      case .invalidMnemonic: return 1
      case .storage: return 2
      case .isConnected: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_AccountError.AccountErrorType] = [
      .storeAccountErrorUnspecified,
      .invalidMnemonic,
      .storage,
      .isConnected,
    ]

  }

  init() {}
}

struct Nym_Vpn_StoreAccountError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorDetail: Nym_Vpn_StoreAccountError.OneOf_ErrorDetail? = nil

  var storageError: String {
    get {
      if case .storageError(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .storageError(newValue)}
  }

  var errorResponse: Nym_Vpn_VpnApiErrorResponse {
    get {
      if case .errorResponse(let v)? = errorDetail {return v}
      return Nym_Vpn_VpnApiErrorResponse()
    }
    set {errorDetail = .errorResponse(newValue)}
  }

  var unexpectedResponse: String {
    get {
      if case .unexpectedResponse(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .unexpectedResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ErrorDetail: Equatable, Sendable {
    case storageError(String)
    case errorResponse(Nym_Vpn_VpnApiErrorResponse)
    case unexpectedResponse(String)

  }

  init() {}
}

struct Nym_Vpn_SyncAccountError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorDetail: Nym_Vpn_SyncAccountError.OneOf_ErrorDetail? = nil

  var noAccountStored: Bool {
    get {
      if case .noAccountStored(let v)? = errorDetail {return v}
      return false
    }
    set {errorDetail = .noAccountStored(newValue)}
  }

  var errorResponse: Nym_Vpn_VpnApiErrorResponse {
    get {
      if case .errorResponse(let v)? = errorDetail {return v}
      return Nym_Vpn_VpnApiErrorResponse()
    }
    set {errorDetail = .errorResponse(newValue)}
  }

  var unexpectedResponse: String {
    get {
      if case .unexpectedResponse(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .unexpectedResponse(newValue)}
  }

  var `internal`: String {
    get {
      if case .internal(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .internal(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ErrorDetail: Equatable, Sendable {
    case noAccountStored(Bool)
    case errorResponse(Nym_Vpn_VpnApiErrorResponse)
    case unexpectedResponse(String)
    case `internal`(String)

  }

  init() {}
}

struct Nym_Vpn_SyncDeviceError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorDetail: Nym_Vpn_SyncDeviceError.OneOf_ErrorDetail? = nil

  var noAccountStored: Bool {
    get {
      if case .noAccountStored(let v)? = errorDetail {return v}
      return false
    }
    set {errorDetail = .noAccountStored(newValue)}
  }

  var noDeviceStored: Bool {
    get {
      if case .noDeviceStored(let v)? = errorDetail {return v}
      return false
    }
    set {errorDetail = .noDeviceStored(newValue)}
  }

  var errorResponse: Nym_Vpn_VpnApiErrorResponse {
    get {
      if case .errorResponse(let v)? = errorDetail {return v}
      return Nym_Vpn_VpnApiErrorResponse()
    }
    set {errorDetail = .errorResponse(newValue)}
  }

  var unexpectedResponse: String {
    get {
      if case .unexpectedResponse(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .unexpectedResponse(newValue)}
  }

  var `internal`: String {
    get {
      if case .internal(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .internal(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ErrorDetail: Equatable, Sendable {
    case noAccountStored(Bool)
    case noDeviceStored(Bool)
    case errorResponse(Nym_Vpn_VpnApiErrorResponse)
    case unexpectedResponse(String)
    case `internal`(String)

  }

  init() {}
}

struct Nym_Vpn_RegisterDeviceError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorDetail: Nym_Vpn_RegisterDeviceError.OneOf_ErrorDetail? = nil

  var noAccountStored: Bool {
    get {
      if case .noAccountStored(let v)? = errorDetail {return v}
      return false
    }
    set {errorDetail = .noAccountStored(newValue)}
  }

  var noDeviceStored: Bool {
    get {
      if case .noDeviceStored(let v)? = errorDetail {return v}
      return false
    }
    set {errorDetail = .noDeviceStored(newValue)}
  }

  var errorResponse: Nym_Vpn_VpnApiErrorResponse {
    get {
      if case .errorResponse(let v)? = errorDetail {return v}
      return Nym_Vpn_VpnApiErrorResponse()
    }
    set {errorDetail = .errorResponse(newValue)}
  }

  var unexpectedResponse: String {
    get {
      if case .unexpectedResponse(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .unexpectedResponse(newValue)}
  }

  var `internal`: String {
    get {
      if case .internal(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .internal(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ErrorDetail: Equatable, Sendable {
    case noAccountStored(Bool)
    case noDeviceStored(Bool)
    case errorResponse(Nym_Vpn_VpnApiErrorResponse)
    case unexpectedResponse(String)
    case `internal`(String)

  }

  init() {}
}

struct Nym_Vpn_ForgetAccountError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorDetail: Nym_Vpn_ForgetAccountError.OneOf_ErrorDetail? = nil

  var registrationInProgress: Bool {
    get {
      if case .registrationInProgress(let v)? = errorDetail {return v}
      return false
    }
    set {errorDetail = .registrationInProgress(newValue)}
  }

  var errorResponse: Nym_Vpn_VpnApiErrorResponse {
    get {
      if case .errorResponse(let v)? = errorDetail {return v}
      return Nym_Vpn_VpnApiErrorResponse()
    }
    set {errorDetail = .errorResponse(newValue)}
  }

  var unexpectedResponse: String {
    get {
      if case .unexpectedResponse(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .unexpectedResponse(newValue)}
  }

  var removeAccount: String {
    get {
      if case .removeAccount(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .removeAccount(newValue)}
  }

  var removeDeviceKeys: String {
    get {
      if case .removeDeviceKeys(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .removeDeviceKeys(newValue)}
  }

  var resetCredentialStore: String {
    get {
      if case .resetCredentialStore(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .resetCredentialStore(newValue)}
  }

  var removeAccountFiles: String {
    get {
      if case .removeAccountFiles(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .removeAccountFiles(newValue)}
  }

  var initDeviceKeys: String {
    get {
      if case .initDeviceKeys(let v)? = errorDetail {return v}
      return String()
    }
    set {errorDetail = .initDeviceKeys(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ErrorDetail: Equatable, Sendable {
    case registrationInProgress(Bool)
    case errorResponse(Nym_Vpn_VpnApiErrorResponse)
    case unexpectedResponse(String)
    case removeAccount(String)
    case removeDeviceKeys(String)
    case resetCredentialStore(String)
    case removeAccountFiles(String)
    case initDeviceKeys(String)

  }

  init() {}
}

struct Nym_Vpn_DeleteLogFileError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_VpnApiErrorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var messageID: String {
    get {return _messageID ?? String()}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {self._messageID = nil}

  var codeReferenceID: String {
    get {return _codeReferenceID ?? String()}
    set {_codeReferenceID = newValue}
  }
  /// Returns true if `codeReferenceID` has been explicitly set.
  var hasCodeReferenceID: Bool {return self._codeReferenceID != nil}
  /// Clears the value of `codeReferenceID`. Subsequent reads from it will return its default value.
  mutating func clearCodeReferenceID() {self._codeReferenceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _messageID: String? = nil
  fileprivate var _codeReferenceID: String? = nil
}

struct Nym_Vpn_RequestZkNymSuccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_RequestZkNymError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outcome: Nym_Vpn_RequestZkNymError.OneOf_Outcome? = nil

  var noAccountStored: Bool {
    get {
      if case .noAccountStored(let v)? = outcome {return v}
      return false
    }
    set {outcome = .noAccountStored(newValue)}
  }

  var noDeviceStored: Bool {
    get {
      if case .noDeviceStored(let v)? = outcome {return v}
      return false
    }
    set {outcome = .noDeviceStored(newValue)}
  }

  var vpnApi: Nym_Vpn_VpnApiErrorResponse {
    get {
      if case .vpnApi(let v)? = outcome {return v}
      return Nym_Vpn_VpnApiErrorResponse()
    }
    set {outcome = .vpnApi(newValue)}
  }

  var unexpectedVpnApiResponse: String {
    get {
      if case .unexpectedVpnApiResponse(let v)? = outcome {return v}
      return String()
    }
    set {outcome = .unexpectedVpnApiResponse(newValue)}
  }

  var storage: String {
    get {
      if case .storage(let v)? = outcome {return v}
      return String()
    }
    set {outcome = .storage(newValue)}
  }

  var `internal`: String {
    get {
      if case .internal(let v)? = outcome {return v}
      return String()
    }
    set {outcome = .internal(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Outcome: Equatable, Sendable {
    case noAccountStored(Bool)
    case noDeviceStored(Bool)
    case vpnApi(Nym_Vpn_VpnApiErrorResponse)
    case unexpectedVpnApiResponse(String)
    case storage(String)
    case `internal`(String)

  }

  init() {}
}

struct Nym_Vpn_RequestZkNymBundle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var successes: [Nym_Vpn_RequestZkNymSuccess] = []

  var failures: [Nym_Vpn_RequestZkNymError] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AccountIdentity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountIdentity: String {
    get {return _accountIdentity ?? String()}
    set {_accountIdentity = newValue}
  }
  /// Returns true if `accountIdentity` has been explicitly set.
  var hasAccountIdentity: Bool {return self._accountIdentity != nil}
  /// Clears the value of `accountIdentity`. Subsequent reads from it will return its default value.
  mutating func clearAccountIdentity() {self._accountIdentity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountIdentity: String? = nil
}

struct Nym_Vpn_StoreAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mnemonic: String = String()

  var nonce: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_StoreAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_IsAccountStoredResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resp: Nym_Vpn_IsAccountStoredResponse.OneOf_Resp? = nil

  var isStored: Bool {
    get {
      if case .isStored(let v)? = resp {return v}
      return false
    }
    set {resp = .isStored(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = resp {return v}
      return Nym_Vpn_AccountError()
    }
    set {resp = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Resp: Equatable, Sendable {
    case isStored(Bool)
    case error(Nym_Vpn_AccountError)

  }

  init() {}
}

struct Nym_Vpn_ForgetAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetAccountIdentityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_GetAccountIdentityResponse.OneOf_ID? = nil

  var accountIdentity: Nym_Vpn_AccountIdentity {
    get {
      if case .accountIdentity(let v)? = id {return v}
      return Nym_Vpn_AccountIdentity()
    }
    set {id = .accountIdentity(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = id {return v}
      return Nym_Vpn_AccountError()
    }
    set {id = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable, Sendable {
    case accountIdentity(Nym_Vpn_AccountIdentity)
    case error(Nym_Vpn_AccountError)

  }

  init() {}
}

struct Nym_Vpn_GetAccountStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Nym_Vpn_GetAccountStateResponse.OneOf_Result? = nil

  var account: Nym_Vpn_GetAccountStateResponse.AccountStateSummary {
    get {
      if case .account(let v)? = result {return v}
      return Nym_Vpn_GetAccountStateResponse.AccountStateSummary()
    }
    set {result = .account(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = result {return v}
      return Nym_Vpn_AccountError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable, Sendable {
    case account(Nym_Vpn_GetAccountStateResponse.AccountStateSummary)
    case error(Nym_Vpn_AccountError)

  }

  struct AccountStateSummary: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mnemonic: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.MnemonicState {
      get {return _storage._mnemonic ?? .unspecified}
      set {_uniqueStorage()._mnemonic = newValue}
    }
    /// Returns true if `mnemonic` has been explicitly set.
    var hasMnemonic: Bool {return _storage._mnemonic != nil}
    /// Clears the value of `mnemonic`. Subsequent reads from it will return its default value.
    mutating func clearMnemonic() {_uniqueStorage()._mnemonic = nil}

    var accountRegistered: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountRegistered {
      get {return _storage._accountRegistered ?? .unspecified}
      set {_uniqueStorage()._accountRegistered = newValue}
    }
    /// Returns true if `accountRegistered` has been explicitly set.
    var hasAccountRegistered: Bool {return _storage._accountRegistered != nil}
    /// Clears the value of `accountRegistered`. Subsequent reads from it will return its default value.
    mutating func clearAccountRegistered() {_uniqueStorage()._accountRegistered = nil}

    var accountSummary: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary {
      get {return _storage._accountSummary ?? Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary()}
      set {_uniqueStorage()._accountSummary = newValue}
    }
    /// Returns true if `accountSummary` has been explicitly set.
    var hasAccountSummary: Bool {return _storage._accountSummary != nil}
    /// Clears the value of `accountSummary`. Subsequent reads from it will return its default value.
    mutating func clearAccountSummary() {_uniqueStorage()._accountSummary = nil}

    var device: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.DeviceState {
      get {return _storage._device ?? .unspecified}
      set {_uniqueStorage()._device = newValue}
    }
    /// Returns true if `device` has been explicitly set.
    var hasDevice: Bool {return _storage._device != nil}
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    mutating func clearDevice() {_uniqueStorage()._device = nil}

    var registerDeviceResult: Nym_Vpn_RegisterDeviceResult {
      get {return _storage._registerDeviceResult ?? Nym_Vpn_RegisterDeviceResult()}
      set {_uniqueStorage()._registerDeviceResult = newValue}
    }
    /// Returns true if `registerDeviceResult` has been explicitly set.
    var hasRegisterDeviceResult: Bool {return _storage._registerDeviceResult != nil}
    /// Clears the value of `registerDeviceResult`. Subsequent reads from it will return its default value.
    mutating func clearRegisterDeviceResult() {_uniqueStorage()._registerDeviceResult = nil}

    /// NOTE: don't reuse tag 6
    /// bool pending_zk_nym = 6;
    var requestZkNymResult: Nym_Vpn_RequestZkNymResult {
      get {return _storage._requestZkNymResult ?? Nym_Vpn_RequestZkNymResult()}
      set {_uniqueStorage()._requestZkNymResult = newValue}
    }
    /// Returns true if `requestZkNymResult` has been explicitly set.
    var hasRequestZkNymResult: Bool {return _storage._requestZkNymResult != nil}
    /// Clears the value of `requestZkNymResult`. Subsequent reads from it will return its default value.
    mutating func clearRequestZkNymResult() {_uniqueStorage()._requestZkNymResult = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum MnemonicState: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unspecified // = 0
      case notStored // = 1
      case stored // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .notStored
        case 2: self = .stored
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .notStored: return 1
        case .stored: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Nym_Vpn_GetAccountStateResponse.AccountStateSummary.MnemonicState] = [
        .unspecified,
        .notStored,
        .stored,
      ]

    }

    enum AccountRegistered: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unspecified // = 0
      case accountRegistered // = 1
      case accountNotRegistered // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .accountRegistered
        case 2: self = .accountNotRegistered
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .accountRegistered: return 1
        case .accountNotRegistered: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountRegistered] = [
        .unspecified,
        .accountRegistered,
        .accountNotRegistered,
      ]

    }

    enum DeviceState: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unspecified // = 0
      case notRegistered // = 1
      case inactive // = 2
      case active // = 3
      case deleteMe // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .notRegistered
        case 2: self = .inactive
        case 3: self = .active
        case 4: self = .deleteMe
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .notRegistered: return 1
        case .inactive: return 2
        case .active: return 3
        case .deleteMe: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Nym_Vpn_GetAccountStateResponse.AccountStateSummary.DeviceState] = [
        .unspecified,
        .notRegistered,
        .inactive,
        .active,
        .deleteMe,
      ]

    }

    struct AccountSummary: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var account: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.AccountState = .unspecified

      var subscription: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.SubscriptionState = .unspecified

      var deviceSummary: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.DeviceSummary {
        get {return _deviceSummary ?? Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.DeviceSummary()}
        set {_deviceSummary = newValue}
      }
      /// Returns true if `deviceSummary` has been explicitly set.
      var hasDeviceSummary: Bool {return self._deviceSummary != nil}
      /// Clears the value of `deviceSummary`. Subsequent reads from it will return its default value.
      mutating func clearDeviceSummary() {self._deviceSummary = nil}

      var fairUsage: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.FairUsageState {
        get {return _fairUsage ?? Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.FairUsageState()}
        set {_fairUsage = newValue}
      }
      /// Returns true if `fairUsage` has been explicitly set.
      var hasFairUsage: Bool {return self._fairUsage != nil}
      /// Clears the value of `fairUsage`. Subsequent reads from it will return its default value.
      mutating func clearFairUsage() {self._fairUsage = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum AccountState: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unspecified // = 0
        case notRegistered // = 1
        case inactive // = 2
        case active // = 3
        case deleteMe // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unspecified
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .notRegistered
          case 2: self = .inactive
          case 3: self = .active
          case 4: self = .deleteMe
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .notRegistered: return 1
          case .inactive: return 2
          case .active: return 3
          case .deleteMe: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.AccountState] = [
          .unspecified,
          .notRegistered,
          .inactive,
          .active,
          .deleteMe,
        ]

      }

      enum SubscriptionState: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unspecified // = 0
        case notRegistered // = 1
        case pending // = 2
        case active // = 3
        case complete // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unspecified
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .notRegistered
          case 2: self = .pending
          case 3: self = .active
          case 4: self = .complete
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .notRegistered: return 1
          case .pending: return 2
          case .active: return 3
          case .complete: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.SubscriptionState] = [
          .unspecified,
          .notRegistered,
          .pending,
          .active,
          .complete,
        ]

      }

      struct DeviceSummary: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var active: UInt64 = 0

        var max: UInt64 = 0

        var remaining: UInt64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct FairUsageState: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var limitGb: UInt64 = 0

        var usedGb: UInt64 = 0

        var resetsOnUtc: String {
          get {return _resetsOnUtc ?? String()}
          set {_resetsOnUtc = newValue}
        }
        /// Returns true if `resetsOnUtc` has been explicitly set.
        var hasResetsOnUtc: Bool {return self._resetsOnUtc != nil}
        /// Clears the value of `resetsOnUtc`. Subsequent reads from it will return its default value.
        mutating func clearResetsOnUtc() {self._resetsOnUtc = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _resetsOnUtc: String? = nil
      }

      init() {}

      fileprivate var _deviceSummary: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.DeviceSummary? = nil
      fileprivate var _fairUsage: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.FairUsageState? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct Nym_Vpn_RegisterDeviceResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_RegisterDeviceResult.RegisterDeviceResultType = .registerDeviceResultUnspecified

  var error: Nym_Vpn_RegisterDeviceError {
    get {return _error ?? Nym_Vpn_RegisterDeviceError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RegisterDeviceResultType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case registerDeviceResultUnspecified // = 0
    case inProgress // = 1
    case success // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .registerDeviceResultUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .registerDeviceResultUnspecified
      case 1: self = .inProgress
      case 2: self = .success
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .registerDeviceResultUnspecified: return 0
      case .inProgress: return 1
      case .success: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_RegisterDeviceResult.RegisterDeviceResultType] = [
      .registerDeviceResultUnspecified,
      .inProgress,
      .success,
      .failed,
    ]

  }

  init() {}

  fileprivate var _error: Nym_Vpn_RegisterDeviceError? = nil
}

/// The status of a zk-nym request. A request can have multiple successes
/// and failures, depending on how many ticket types were requested.
struct Nym_Vpn_RequestZkNymResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_RequestZkNymResult.RequestZkNymResultType = .requestZkNymResultUnspecified

  var successes: [Nym_Vpn_RequestZkNymSuccess] = []

  var failures: [Nym_Vpn_RequestZkNymError] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RequestZkNymResultType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case requestZkNymResultUnspecified // = 0
    case inProgress // = 1
    case done // = 4
    case error // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .requestZkNymResultUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .requestZkNymResultUnspecified
      case 1: self = .inProgress
      case 4: self = .done
      case 5: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .requestZkNymResultUnspecified: return 0
      case .inProgress: return 1
      case .done: return 4
      case .error: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_RequestZkNymResult.RequestZkNymResultType] = [
      .requestZkNymResultUnspecified,
      .inProgress,
      .done,
      .error,
    ]

  }

  init() {}
}

struct Nym_Vpn_RefreshAccountStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountUsageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Nym_Vpn_GetAccountUsageResponse.OneOf_Result? = nil

  var accountUsages: Nym_Vpn_GetAccountUsageResponse.AccountUsages {
    get {
      if case .accountUsages(let v)? = result {return v}
      return Nym_Vpn_GetAccountUsageResponse.AccountUsages()
    }
    set {result = .accountUsages(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = result {return v}
      return Nym_Vpn_AccountError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable, Sendable {
    case accountUsages(Nym_Vpn_GetAccountUsageResponse.AccountUsages)
    case error(Nym_Vpn_AccountError)

  }

  struct AccountUsages: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var accountUsages: [Nym_Vpn_GetAccountUsageResponse.AccountUsage] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AccountUsage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var createdOnUtc: String = String()

    var lastUpdatedUtc: String = String()

    var id: String = String()

    var subscriptionID: String = String()

    var validUntilUtc: String = String()

    var validFromUtc: String = String()

    var bandwidthAllowanceGb: Double = 0

    var bandwidthUsedGb: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Nym_Vpn_ResetDeviceIdentityRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 32 byte seed, [u8; 32]
  var seed: Data {
    get {return _seed ?? Data()}
    set {_seed = newValue}
  }
  /// Returns true if `seed` has been explicitly set.
  var hasSeed: Bool {return self._seed != nil}
  /// Clears the value of `seed`. Subsequent reads from it will return its default value.
  mutating func clearSeed() {self._seed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seed: Data? = nil
}

struct Nym_Vpn_ResetDeviceIdentityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetDeviceIdentityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_GetDeviceIdentityResponse.OneOf_ID? = nil

  var deviceIdentity: String {
    get {
      if case .deviceIdentity(let v)? = id {return v}
      return String()
    }
    set {id = .deviceIdentity(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = id {return v}
      return Nym_Vpn_AccountError()
    }
    set {id = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable, Sendable {
    case deviceIdentity(String)
    case error(Nym_Vpn_AccountError)

  }

  init() {}
}

struct Nym_Vpn_RegisterDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetDevicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Nym_Vpn_GetDevicesResponse.OneOf_Result? = nil

  var devices: Nym_Vpn_GetDevicesResponse.Devices {
    get {
      if case .devices(let v)? = result {return v}
      return Nym_Vpn_GetDevicesResponse.Devices()
    }
    set {result = .devices(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = result {return v}
      return Nym_Vpn_AccountError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable, Sendable {
    case devices(Nym_Vpn_GetDevicesResponse.Devices)
    case error(Nym_Vpn_AccountError)

  }

  struct Device: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var createdOnUtc: String = String()

    var lastUpdatedUtc: String = String()

    var deviceIdentityKey: String = String()

    var status: Nym_Vpn_GetDevicesResponse.Device.DeviceStatus = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum DeviceStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unspecified // = 0
      case active // = 1
      case inactive // = 2
      case deleteMe // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .active
        case 2: self = .inactive
        case 3: self = .deleteMe
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .active: return 1
        case .inactive: return 2
        case .deleteMe: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Nym_Vpn_GetDevicesResponse.Device.DeviceStatus] = [
        .unspecified,
        .active,
        .inactive,
        .deleteMe,
      ]

    }

    init() {}
  }

  struct Devices: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var devices: [Nym_Vpn_GetDevicesResponse.Device] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Nym_Vpn_RequestZkNymResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetDeviceZkNymsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetZkNymsAvailableForDownloadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetZkNymByIdRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetZkNymByIdResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_ConfirmZkNymDownloadedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConfirmZkNymDownloadedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Nym_Vpn_AccountError {
    get {return _error ?? Nym_Vpn_AccountError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_AccountError? = nil
}

struct Nym_Vpn_GetAvailableTicketsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resp: Nym_Vpn_GetAvailableTicketsResponse.OneOf_Resp? = nil

  var availableTickets: Nym_Vpn_GetAvailableTicketsResponse.AvailableTickets {
    get {
      if case .availableTickets(let v)? = resp {return v}
      return Nym_Vpn_GetAvailableTicketsResponse.AvailableTickets()
    }
    set {resp = .availableTickets(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = resp {return v}
      return Nym_Vpn_AccountError()
    }
    set {resp = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Resp: Equatable, Sendable {
    case availableTickets(Nym_Vpn_GetAvailableTicketsResponse.AvailableTickets)
    case error(Nym_Vpn_AccountError)

  }

  struct AvailableTickets: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Remaining number of mixnet entry tickets
    var mixnetEntryTickets: UInt64 = 0

    /// Remaining mixnet entry data in bytes
    var mixnetEntryData: UInt64 = 0

    /// Remaining mixnet entry data formatted to a string using SI units
    var mixnetEntryDataSi: String = String()

    /// Remaining number of mixnet exit tickets
    var mixnetExitTickets: UInt64 = 0

    /// Remaining mixnet exit data in bytes
    var mixnetExitData: UInt64 = 0

    /// Remaining mixnet exit data formatted to a string using SI units
    var mixnetExitDataSi: String = String()

    /// Remaining number of vpn entry tickets
    var vpnEntryTickets: UInt64 = 0

    /// Remaining vpn entry data in bytes
    var vpnEntryData: UInt64 = 0

    /// Remaining vpn entry data formatted to a string using SI units
    var vpnEntryDataSi: String = String()

    /// Remaining number of vpn exit tickets
    var vpnExitTickets: UInt64 = 0

    /// Remaining vpn exit data in bytes
    var vpnExitData: UInt64 = 0

    /// Remaining vpn exit data formatted to a string using SI units
    var vpnExitDataSi: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Nym_Vpn_DeleteLogFileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_DeleteLogFileError {
    get {return _error ?? Nym_Vpn_DeleteLogFileError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_DeleteLogFileError? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nym.vpn"

extension Nym_Vpn_AccountError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .storeAccountErrorUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountError, rhs: Nym_Vpn_AccountError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountError.AccountErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORE_ACCOUNT_ERROR_UNSPECIFIED"),
    1: .same(proto: "INVALID_MNEMONIC"),
    2: .same(proto: "STORAGE"),
    3: .same(proto: "IS_CONNECTED"),
  ]
}

extension Nym_Vpn_StoreAccountError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "storage_error"),
    2: .standard(proto: "error_response"),
    3: .standard(proto: "unexpected_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .storageError(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_VpnApiErrorResponse?
        var hadOneofValue = false
        if let current = self.errorDetail {
          hadOneofValue = true
          if case .errorResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorDetail = .errorResponse(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .unexpectedResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.errorDetail {
    case .storageError?: try {
      guard case .storageError(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .errorResponse?: try {
      guard case .errorResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unexpectedResponse?: try {
      guard case .unexpectedResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountError, rhs: Nym_Vpn_StoreAccountError) -> Bool {
    if lhs.errorDetail != rhs.errorDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SyncAccountError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncAccountError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "no_account_stored"),
    2: .standard(proto: "error_response"),
    3: .standard(proto: "unexpected_response"),
    4: .same(proto: "internal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .noAccountStored(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_VpnApiErrorResponse?
        var hadOneofValue = false
        if let current = self.errorDetail {
          hadOneofValue = true
          if case .errorResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorDetail = .errorResponse(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .unexpectedResponse(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .internal(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.errorDetail {
    case .noAccountStored?: try {
      guard case .noAccountStored(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .errorResponse?: try {
      guard case .errorResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unexpectedResponse?: try {
      guard case .unexpectedResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .internal?: try {
      guard case .internal(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SyncAccountError, rhs: Nym_Vpn_SyncAccountError) -> Bool {
    if lhs.errorDetail != rhs.errorDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SyncDeviceError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncDeviceError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "no_account_stored"),
    2: .standard(proto: "no_device_stored"),
    3: .standard(proto: "error_response"),
    4: .standard(proto: "unexpected_response"),
    5: .same(proto: "internal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .noAccountStored(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .noDeviceStored(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_VpnApiErrorResponse?
        var hadOneofValue = false
        if let current = self.errorDetail {
          hadOneofValue = true
          if case .errorResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorDetail = .errorResponse(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .unexpectedResponse(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .internal(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.errorDetail {
    case .noAccountStored?: try {
      guard case .noAccountStored(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .noDeviceStored?: try {
      guard case .noDeviceStored(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .errorResponse?: try {
      guard case .errorResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .unexpectedResponse?: try {
      guard case .unexpectedResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .internal?: try {
      guard case .internal(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SyncDeviceError, rhs: Nym_Vpn_SyncDeviceError) -> Bool {
    if lhs.errorDetail != rhs.errorDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "no_account_stored"),
    2: .standard(proto: "no_device_stored"),
    3: .standard(proto: "error_response"),
    4: .standard(proto: "unexpected_response"),
    5: .same(proto: "internal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .noAccountStored(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .noDeviceStored(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_VpnApiErrorResponse?
        var hadOneofValue = false
        if let current = self.errorDetail {
          hadOneofValue = true
          if case .errorResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorDetail = .errorResponse(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .unexpectedResponse(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .internal(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.errorDetail {
    case .noAccountStored?: try {
      guard case .noAccountStored(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .noDeviceStored?: try {
      guard case .noDeviceStored(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .errorResponse?: try {
      guard case .errorResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .unexpectedResponse?: try {
      guard case .unexpectedResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .internal?: try {
      guard case .internal(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RegisterDeviceError, rhs: Nym_Vpn_RegisterDeviceError) -> Bool {
    if lhs.errorDetail != rhs.errorDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ForgetAccountError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForgetAccountError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "registration_in_progress"),
    2: .standard(proto: "error_response"),
    3: .standard(proto: "unexpected_response"),
    4: .standard(proto: "remove_account"),
    5: .standard(proto: "remove_device_keys"),
    6: .standard(proto: "reset_credential_store"),
    7: .standard(proto: "remove_account_files"),
    8: .standard(proto: "init_device_keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .registrationInProgress(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_VpnApiErrorResponse?
        var hadOneofValue = false
        if let current = self.errorDetail {
          hadOneofValue = true
          if case .errorResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorDetail = .errorResponse(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .unexpectedResponse(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .removeAccount(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .removeDeviceKeys(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .resetCredentialStore(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .removeAccountFiles(v)
        }
      }()
      case 8: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.errorDetail != nil {try decoder.handleConflictingOneOf()}
          self.errorDetail = .initDeviceKeys(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.errorDetail {
    case .registrationInProgress?: try {
      guard case .registrationInProgress(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .errorResponse?: try {
      guard case .errorResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unexpectedResponse?: try {
      guard case .unexpectedResponse(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .removeAccount?: try {
      guard case .removeAccount(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .removeDeviceKeys?: try {
      guard case .removeDeviceKeys(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .resetCredentialStore?: try {
      guard case .resetCredentialStore(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .removeAccountFiles?: try {
      guard case .removeAccountFiles(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case .initDeviceKeys?: try {
      guard case .initDeviceKeys(let v)? = self.errorDetail else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ForgetAccountError, rhs: Nym_Vpn_ForgetAccountError) -> Bool {
    if lhs.errorDetail != rhs.errorDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DeleteLogFileError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteLogFileError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DeleteLogFileError, rhs: Nym_Vpn_DeleteLogFileError) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_VpnApiErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VpnApiErrorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .standard(proto: "message_id"),
    3: .standard(proto: "code_reference_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._messageID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._codeReferenceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try { if let v = self._messageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._codeReferenceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_VpnApiErrorResponse, rhs: Nym_Vpn_VpnApiErrorResponse) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs._codeReferenceID != rhs._codeReferenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymSuccess, rhs: Nym_Vpn_RequestZkNymSuccess) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "no_account_stored"),
    2: .standard(proto: "no_device_stored"),
    3: .standard(proto: "vpn_api"),
    4: .standard(proto: "unexpected_vpn_api_response"),
    5: .same(proto: "storage"),
    6: .same(proto: "internal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.outcome != nil {try decoder.handleConflictingOneOf()}
          self.outcome = .noAccountStored(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.outcome != nil {try decoder.handleConflictingOneOf()}
          self.outcome = .noDeviceStored(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_VpnApiErrorResponse?
        var hadOneofValue = false
        if let current = self.outcome {
          hadOneofValue = true
          if case .vpnApi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.outcome = .vpnApi(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.outcome != nil {try decoder.handleConflictingOneOf()}
          self.outcome = .unexpectedVpnApiResponse(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.outcome != nil {try decoder.handleConflictingOneOf()}
          self.outcome = .storage(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.outcome != nil {try decoder.handleConflictingOneOf()}
          self.outcome = .internal(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.outcome {
    case .noAccountStored?: try {
      guard case .noAccountStored(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .noDeviceStored?: try {
      guard case .noDeviceStored(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .vpnApi?: try {
      guard case .vpnApi(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .unexpectedVpnApiResponse?: try {
      guard case .unexpectedVpnApiResponse(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .storage?: try {
      guard case .storage(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .internal?: try {
      guard case .internal(let v)? = self.outcome else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymError, rhs: Nym_Vpn_RequestZkNymError) -> Bool {
    if lhs.outcome != rhs.outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "successes"),
    2: .same(proto: "failures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.successes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.successes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.successes, fieldNumber: 1)
    }
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymBundle, rhs: Nym_Vpn_RequestZkNymBundle) -> Bool {
    if lhs.successes != rhs.successes {return false}
    if lhs.failures != rhs.failures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._accountIdentity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountIdentity {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountIdentity, rhs: Nym_Vpn_AccountIdentity) -> Bool {
    if lhs._accountIdentity != rhs._accountIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountRequest, rhs: Nym_Vpn_StoreAccountRequest) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_StoreAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_StoreAccountResponse, rhs: Nym_Vpn_StoreAccountResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_IsAccountStoredResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsAccountStoredResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_stored"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.resp != nil {try decoder.handleConflictingOneOf()}
          self.resp = .isStored(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.resp {
    case .isStored?: try {
      guard case .isStored(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_IsAccountStoredResponse, rhs: Nym_Vpn_IsAccountStoredResponse) -> Bool {
    if lhs.resp != rhs.resp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ForgetAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForgetAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ForgetAccountResponse, rhs: Nym_Vpn_ForgetAccountResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_identity"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_AccountIdentity?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .accountIdentity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .accountIdentity(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .accountIdentity?: try {
      guard case .accountIdentity(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountIdentityResponse, rhs: Nym_Vpn_GetAccountIdentityResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_GetAccountStateResponse.AccountStateSummary?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .account(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .account?: try {
      guard case .account(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateResponse, rhs: Nym_Vpn_GetAccountStateResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetAccountStateResponse.protoMessageName + ".AccountStateSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .standard(proto: "account_registered"),
    3: .standard(proto: "account_summary"),
    4: .same(proto: "device"),
    5: .standard(proto: "register_device_result"),
    7: .standard(proto: "request_zk_nym_result"),
  ]

  fileprivate class _StorageClass {
    var _mnemonic: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.MnemonicState? = nil
    var _accountRegistered: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountRegistered? = nil
    var _accountSummary: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary? = nil
    var _device: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.DeviceState? = nil
    var _registerDeviceResult: Nym_Vpn_RegisterDeviceResult? = nil
    var _requestZkNymResult: Nym_Vpn_RequestZkNymResult? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _mnemonic = source._mnemonic
      _accountRegistered = source._accountRegistered
      _accountSummary = source._accountSummary
      _device = source._device
      _registerDeviceResult = source._registerDeviceResult
      _requestZkNymResult = source._requestZkNymResult
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._mnemonic) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._accountRegistered) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._accountSummary) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._device) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._registerDeviceResult) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._requestZkNymResult) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._mnemonic {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._accountRegistered {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._accountSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._device {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._registerDeviceResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._requestZkNymResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateResponse.AccountStateSummary, rhs: Nym_Vpn_GetAccountStateResponse.AccountStateSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mnemonic != rhs_storage._mnemonic {return false}
        if _storage._accountRegistered != rhs_storage._accountRegistered {return false}
        if _storage._accountSummary != rhs_storage._accountSummary {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._registerDeviceResult != rhs_storage._registerDeviceResult {return false}
        if _storage._requestZkNymResult != rhs_storage._requestZkNymResult {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary.MnemonicState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MNEMONIC_STATE_UNSPECIFIED"),
    1: .same(proto: "MNEMONIC_STATE_NOT_STORED"),
    2: .same(proto: "MNEMONIC_STATE_STORED"),
  ]
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountRegistered: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCOUNT_REGISTERED_UNSPECIFIED"),
    1: .same(proto: "ACCOUNT_REGISTERED"),
    2: .same(proto: "ACCOUNT_NOT_REGISTERED"),
  ]
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary.DeviceState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_STATE_UNSPECIFIED"),
    1: .same(proto: "DEVICE_STATE_NOT_REGISTERED"),
    2: .same(proto: "DEVICE_STATE_INACTIVE"),
    3: .same(proto: "DEVICE_STATE_ACTIVE"),
    4: .same(proto: "DEVICE_STATE_DELETE_ME"),
  ]
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetAccountStateResponse.AccountStateSummary.protoMessageName + ".AccountSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "subscription"),
    3: .standard(proto: "device_summary"),
    4: .standard(proto: "fair_usage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscription) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deviceSummary) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fairUsage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.account != .unspecified {
      try visitor.visitSingularEnumField(value: self.account, fieldNumber: 1)
    }
    if self.subscription != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscription, fieldNumber: 2)
    }
    try { if let v = self._deviceSummary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fairUsage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary, rhs: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.subscription != rhs.subscription {return false}
    if lhs._deviceSummary != rhs._deviceSummary {return false}
    if lhs._fairUsage != rhs._fairUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.AccountState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCOUNT_STATE_UNSPECIFIED"),
    1: .same(proto: "ACCOUNT_STATE_NOT_REGISTERED"),
    2: .same(proto: "ACCOUNT_STATE_INACTIVE"),
    3: .same(proto: "ACCOUNT_STATE_ACTIVE"),
    4: .same(proto: "ACCOUNT_STATE_DELETE_ME"),
  ]
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.SubscriptionState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_STATE_UNSPECIFIED"),
    1: .same(proto: "SUBSCRIPTION_STATE_NOT_REGISTERED"),
    2: .same(proto: "SUBSCRIPTION_STATE_PENDING"),
    3: .same(proto: "SUBSCRIPTION_STATE_ACTIVE"),
    4: .same(proto: "SUBSCRIPTION_STATE_COMPLETE"),
  ]
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.DeviceSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.protoMessageName + ".DeviceSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .same(proto: "max"),
    3: .same(proto: "remaining"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.active) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.max) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.remaining) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.active != 0 {
      try visitor.visitSingularUInt64Field(value: self.active, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularUInt64Field(value: self.max, fieldNumber: 2)
    }
    if self.remaining != 0 {
      try visitor.visitSingularUInt64Field(value: self.remaining, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.DeviceSummary, rhs: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.DeviceSummary) -> Bool {
    if lhs.active != rhs.active {return false}
    if lhs.max != rhs.max {return false}
    if lhs.remaining != rhs.remaining {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.FairUsageState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.protoMessageName + ".FairUsageState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_gb"),
    2: .standard(proto: "used_gb"),
    3: .standard(proto: "resets_on_utc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.limitGb) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.usedGb) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._resetsOnUtc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.limitGb != 0 {
      try visitor.visitSingularUInt64Field(value: self.limitGb, fieldNumber: 1)
    }
    if self.usedGb != 0 {
      try visitor.visitSingularUInt64Field(value: self.usedGb, fieldNumber: 2)
    }
    try { if let v = self._resetsOnUtc {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.FairUsageState, rhs: Nym_Vpn_GetAccountStateResponse.AccountStateSummary.AccountSummary.FairUsageState) -> Bool {
    if lhs.limitGb != rhs.limitGb {return false}
    if lhs.usedGb != rhs.usedGb {return false}
    if lhs._resetsOnUtc != rhs._resetsOnUtc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .registerDeviceResultUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RegisterDeviceResult, rhs: Nym_Vpn_RegisterDeviceResult) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceResult.RegisterDeviceResultType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGISTER_DEVICE_RESULT_UNSPECIFIED"),
    1: .same(proto: "IN_PROGRESS"),
    2: .same(proto: "SUCCESS"),
    3: .same(proto: "FAILED"),
  ]
}

extension Nym_Vpn_RequestZkNymResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "successes"),
    3: .same(proto: "failures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.successes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .requestZkNymResultUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.successes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.successes, fieldNumber: 2)
    }
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymResult, rhs: Nym_Vpn_RequestZkNymResult) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.successes != rhs.successes {return false}
    if lhs.failures != rhs.failures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymResult.RequestZkNymResultType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_ZK_NYM_RESULT_UNSPECIFIED"),
    1: .same(proto: "IN_PROGRESS"),
    4: .same(proto: "DONE"),
    5: .same(proto: "ERROR"),
  ]
}

extension Nym_Vpn_RefreshAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshAccountStateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RefreshAccountStateResponse, rhs: Nym_Vpn_RefreshAccountStateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountUsageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountUsageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_usages"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_GetAccountUsageResponse.AccountUsages?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .accountUsages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .accountUsages(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .accountUsages?: try {
      guard case .accountUsages(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountUsageResponse, rhs: Nym_Vpn_GetAccountUsageResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountUsageResponse.AccountUsages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetAccountUsageResponse.protoMessageName + ".AccountUsages"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_usages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accountUsages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountUsages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountUsages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountUsageResponse.AccountUsages, rhs: Nym_Vpn_GetAccountUsageResponse.AccountUsages) -> Bool {
    if lhs.accountUsages != rhs.accountUsages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountUsageResponse.AccountUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetAccountUsageResponse.protoMessageName + ".AccountUsage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_on_utc"),
    2: .standard(proto: "last_updated_utc"),
    3: .same(proto: "id"),
    4: .standard(proto: "subscription_id"),
    5: .standard(proto: "valid_until_utc"),
    6: .standard(proto: "valid_from_utc"),
    7: .standard(proto: "bandwidth_allowance_gb"),
    8: .standard(proto: "bandwidth_used_gb"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.createdOnUtc) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastUpdatedUtc) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.validUntilUtc) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.validFromUtc) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.bandwidthAllowanceGb) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.bandwidthUsedGb) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.createdOnUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.createdOnUtc, fieldNumber: 1)
    }
    if !self.lastUpdatedUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.lastUpdatedUtc, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 4)
    }
    if !self.validUntilUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.validUntilUtc, fieldNumber: 5)
    }
    if !self.validFromUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.validFromUtc, fieldNumber: 6)
    }
    if self.bandwidthAllowanceGb.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.bandwidthAllowanceGb, fieldNumber: 7)
    }
    if self.bandwidthUsedGb.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.bandwidthUsedGb, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountUsageResponse.AccountUsage, rhs: Nym_Vpn_GetAccountUsageResponse.AccountUsage) -> Bool {
    if lhs.createdOnUtc != rhs.createdOnUtc {return false}
    if lhs.lastUpdatedUtc != rhs.lastUpdatedUtc {return false}
    if lhs.id != rhs.id {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.validUntilUtc != rhs.validUntilUtc {return false}
    if lhs.validFromUtc != rhs.validFromUtc {return false}
    if lhs.bandwidthAllowanceGb != rhs.bandwidthAllowanceGb {return false}
    if lhs.bandwidthUsedGb != rhs.bandwidthUsedGb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ResetDeviceIdentityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetDeviceIdentityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._seed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._seed {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ResetDeviceIdentityRequest, rhs: Nym_Vpn_ResetDeviceIdentityRequest) -> Bool {
    if lhs._seed != rhs._seed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ResetDeviceIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetDeviceIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ResetDeviceIdentityResponse, rhs: Nym_Vpn_ResetDeviceIdentityResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_identity"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.id != nil {try decoder.handleConflictingOneOf()}
          self.id = .deviceIdentity(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .deviceIdentity?: try {
      guard case .deviceIdentity(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceIdentityResponse, rhs: Nym_Vpn_GetDeviceIdentityResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RegisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RegisterDeviceResponse, rhs: Nym_Vpn_RegisterDeviceResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_GetDevicesResponse.Devices?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .devices(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .devices(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .devices?: try {
      guard case .devices(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDevicesResponse, rhs: Nym_Vpn_GetDevicesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDevicesResponse.Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetDevicesResponse.protoMessageName + ".Device"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_on_utc"),
    2: .standard(proto: "last_updated_utc"),
    3: .standard(proto: "device_identity_key"),
    4: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.createdOnUtc) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastUpdatedUtc) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceIdentityKey) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.createdOnUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.createdOnUtc, fieldNumber: 1)
    }
    if !self.lastUpdatedUtc.isEmpty {
      try visitor.visitSingularStringField(value: self.lastUpdatedUtc, fieldNumber: 2)
    }
    if !self.deviceIdentityKey.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceIdentityKey, fieldNumber: 3)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDevicesResponse.Device, rhs: Nym_Vpn_GetDevicesResponse.Device) -> Bool {
    if lhs.createdOnUtc != rhs.createdOnUtc {return false}
    if lhs.lastUpdatedUtc != rhs.lastUpdatedUtc {return false}
    if lhs.deviceIdentityKey != rhs.deviceIdentityKey {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDevicesResponse.Device.DeviceStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_STATUS_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "INACTIVE"),
    3: .same(proto: "DELETE_ME"),
  ]
}

extension Nym_Vpn_GetDevicesResponse.Devices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetDevicesResponse.protoMessageName + ".Devices"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDevicesResponse.Devices, rhs: Nym_Vpn_GetDevicesResponse.Devices) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_RequestZkNymResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestZkNymResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_RequestZkNymResponse, rhs: Nym_Vpn_RequestZkNymResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetDeviceZkNymsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDeviceZkNymsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetDeviceZkNymsResponse, rhs: Nym_Vpn_GetDeviceZkNymsResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetZkNymsAvailableForDownloadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetZkNymsAvailableForDownloadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetZkNymsAvailableForDownloadResponse, rhs: Nym_Vpn_GetZkNymsAvailableForDownloadResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetZkNymByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetZkNymByIdRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetZkNymByIdRequest, rhs: Nym_Vpn_GetZkNymByIdRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetZkNymByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetZkNymByIdResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetZkNymByIdResponse, rhs: Nym_Vpn_GetZkNymByIdResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConfirmZkNymDownloadedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmZkNymDownloadedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConfirmZkNymDownloadedRequest, rhs: Nym_Vpn_ConfirmZkNymDownloadedRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConfirmZkNymDownloadedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfirmZkNymDownloadedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConfirmZkNymDownloadedResponse, rhs: Nym_Vpn_ConfirmZkNymDownloadedResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAvailableTicketsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAvailableTicketsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_tickets"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_GetAvailableTicketsResponse.AvailableTickets?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .availableTickets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .availableTickets(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.resp {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resp = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.resp {
    case .availableTickets?: try {
      guard case .availableTickets(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.resp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAvailableTicketsResponse, rhs: Nym_Vpn_GetAvailableTicketsResponse) -> Bool {
    if lhs.resp != rhs.resp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAvailableTicketsResponse.AvailableTickets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_GetAvailableTicketsResponse.protoMessageName + ".AvailableTickets"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mixnet_entry_tickets"),
    2: .standard(proto: "mixnet_entry_data"),
    3: .standard(proto: "mixnet_entry_data_si"),
    4: .standard(proto: "mixnet_exit_tickets"),
    5: .standard(proto: "mixnet_exit_data"),
    6: .standard(proto: "mixnet_exit_data_si"),
    7: .standard(proto: "vpn_entry_tickets"),
    8: .standard(proto: "vpn_entry_data"),
    9: .standard(proto: "vpn_entry_data_si"),
    10: .standard(proto: "vpn_exit_tickets"),
    11: .standard(proto: "vpn_exit_data"),
    12: .standard(proto: "vpn_exit_data_si"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.mixnetEntryTickets) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.mixnetEntryData) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mixnetEntryDataSi) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.mixnetExitTickets) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.mixnetExitData) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.mixnetExitDataSi) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.vpnEntryTickets) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.vpnEntryData) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.vpnEntryDataSi) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.vpnExitTickets) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.vpnExitData) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.vpnExitDataSi) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mixnetEntryTickets != 0 {
      try visitor.visitSingularUInt64Field(value: self.mixnetEntryTickets, fieldNumber: 1)
    }
    if self.mixnetEntryData != 0 {
      try visitor.visitSingularUInt64Field(value: self.mixnetEntryData, fieldNumber: 2)
    }
    if !self.mixnetEntryDataSi.isEmpty {
      try visitor.visitSingularStringField(value: self.mixnetEntryDataSi, fieldNumber: 3)
    }
    if self.mixnetExitTickets != 0 {
      try visitor.visitSingularUInt64Field(value: self.mixnetExitTickets, fieldNumber: 4)
    }
    if self.mixnetExitData != 0 {
      try visitor.visitSingularUInt64Field(value: self.mixnetExitData, fieldNumber: 5)
    }
    if !self.mixnetExitDataSi.isEmpty {
      try visitor.visitSingularStringField(value: self.mixnetExitDataSi, fieldNumber: 6)
    }
    if self.vpnEntryTickets != 0 {
      try visitor.visitSingularUInt64Field(value: self.vpnEntryTickets, fieldNumber: 7)
    }
    if self.vpnEntryData != 0 {
      try visitor.visitSingularUInt64Field(value: self.vpnEntryData, fieldNumber: 8)
    }
    if !self.vpnEntryDataSi.isEmpty {
      try visitor.visitSingularStringField(value: self.vpnEntryDataSi, fieldNumber: 9)
    }
    if self.vpnExitTickets != 0 {
      try visitor.visitSingularUInt64Field(value: self.vpnExitTickets, fieldNumber: 10)
    }
    if self.vpnExitData != 0 {
      try visitor.visitSingularUInt64Field(value: self.vpnExitData, fieldNumber: 11)
    }
    if !self.vpnExitDataSi.isEmpty {
      try visitor.visitSingularStringField(value: self.vpnExitDataSi, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAvailableTicketsResponse.AvailableTickets, rhs: Nym_Vpn_GetAvailableTicketsResponse.AvailableTickets) -> Bool {
    if lhs.mixnetEntryTickets != rhs.mixnetEntryTickets {return false}
    if lhs.mixnetEntryData != rhs.mixnetEntryData {return false}
    if lhs.mixnetEntryDataSi != rhs.mixnetEntryDataSi {return false}
    if lhs.mixnetExitTickets != rhs.mixnetExitTickets {return false}
    if lhs.mixnetExitData != rhs.mixnetExitData {return false}
    if lhs.mixnetExitDataSi != rhs.mixnetExitDataSi {return false}
    if lhs.vpnEntryTickets != rhs.vpnEntryTickets {return false}
    if lhs.vpnEntryData != rhs.vpnEntryData {return false}
    if lhs.vpnEntryDataSi != rhs.vpnEntryDataSi {return false}
    if lhs.vpnExitTickets != rhs.vpnExitTickets {return false}
    if lhs.vpnExitData != rhs.vpnExitData {return false}
    if lhs.vpnExitDataSi != rhs.vpnExitDataSi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DeleteLogFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteLogFileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DeleteLogFileResponse, rhs: Nym_Vpn_DeleteLogFileResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
