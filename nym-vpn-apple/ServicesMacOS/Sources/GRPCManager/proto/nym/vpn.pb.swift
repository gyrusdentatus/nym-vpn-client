// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vpn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Nym_Vpn_Score: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case low // = 1
  case medium // = 2
  case high // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .low
    case 2: self = .medium
    case 3: self = .high
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .low: return 1
    case .medium: return 2
    case .high: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_Score] = [
    .none,
    .low,
    .medium,
    .high,
  ]

}

enum Nym_Vpn_GatewayType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case mixnetEntry // = 1
  case mixnetExit // = 2
  case wg // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .mixnetEntry
    case 2: self = .mixnetExit
    case 3: self = .wg
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .mixnetEntry: return 1
    case .mixnetExit: return 2
    case .wg: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nym_Vpn_GatewayType] = [
    .unspecified,
    .mixnetEntry,
    .mixnetExit,
    .wg,
  ]

}

/// Represents the identity of a gateway
struct Nym_Vpn_Gateway: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a nym-address of the form id.enc@gateway
struct Nym_Vpn_Address: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: String = String()

  var gatewayID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var twoLetterIsoCountryCode: String = String()

  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
}

struct Nym_Vpn_EntryNode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryNodeEnum: Nym_Vpn_EntryNode.OneOf_EntryNodeEnum? = nil

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {entryNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = entryNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {entryNodeEnum = .location(newValue)}
  }

  var randomLowLatency: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .randomLowLatency(let v)? = entryNodeEnum {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {entryNodeEnum = .randomLowLatency(newValue)}
  }

  var random: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .random(let v)? = entryNodeEnum {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {entryNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_EntryNodeEnum: Equatable, Sendable {
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case randomLowLatency(SwiftProtobuf.Google_Protobuf_Empty)
    case random(SwiftProtobuf.Google_Protobuf_Empty)

  }

  init() {}
}

struct Nym_Vpn_ExitNode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exitNodeEnum: Nym_Vpn_ExitNode.OneOf_ExitNodeEnum? = nil

  var address: Nym_Vpn_Address {
    get {
      if case .address(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Address()
    }
    set {exitNodeEnum = .address(newValue)}
  }

  var gateway: Nym_Vpn_Gateway {
    get {
      if case .gateway(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Gateway()
    }
    set {exitNodeEnum = .gateway(newValue)}
  }

  var location: Nym_Vpn_Location {
    get {
      if case .location(let v)? = exitNodeEnum {return v}
      return Nym_Vpn_Location()
    }
    set {exitNodeEnum = .location(newValue)}
  }

  var random: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .random(let v)? = exitNodeEnum {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {exitNodeEnum = .random(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ExitNodeEnum: Equatable, Sendable {
    case address(Nym_Vpn_Address)
    case gateway(Nym_Vpn_Gateway)
    case location(Nym_Vpn_Location)
    case random(SwiftProtobuf.Google_Protobuf_Empty)

  }

  init() {}
}

struct Nym_Vpn_MixConnectedStateDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: Nym_Vpn_Address {
    get {return _nymAddress ?? Nym_Vpn_Address()}
    set {_nymAddress = newValue}
  }
  /// Returns true if `nymAddress` has been explicitly set.
  var hasNymAddress: Bool {return self._nymAddress != nil}
  /// Clears the value of `nymAddress`. Subsequent reads from it will return its default value.
  mutating func clearNymAddress() {self._nymAddress = nil}

  var exitIpr: Nym_Vpn_Address {
    get {return _exitIpr ?? Nym_Vpn_Address()}
    set {_exitIpr = newValue}
  }
  /// Returns true if `exitIpr` has been explicitly set.
  var hasExitIpr: Bool {return self._exitIpr != nil}
  /// Clears the value of `exitIpr`. Subsequent reads from it will return its default value.
  mutating func clearExitIpr() {self._exitIpr = nil}

  var ipv4: String = String()

  var ipv6: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nymAddress: Nym_Vpn_Address? = nil
  fileprivate var _exitIpr: Nym_Vpn_Address? = nil
}

struct Nym_Vpn_WgConnectedStateDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryIpv4: String = String()

  var exitIpv4: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectedStateDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectedStateDetails: Nym_Vpn_ConnectedStateDetails.OneOf_ConnectedStateDetails? = nil

  var mix: Nym_Vpn_MixConnectedStateDetails {
    get {
      if case .mix(let v)? = connectedStateDetails {return v}
      return Nym_Vpn_MixConnectedStateDetails()
    }
    set {connectedStateDetails = .mix(newValue)}
  }

  var wg: Nym_Vpn_WgConnectedStateDetails {
    get {
      if case .wg(let v)? = connectedStateDetails {return v}
      return Nym_Vpn_WgConnectedStateDetails()
    }
    set {connectedStateDetails = .wg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ConnectedStateDetails: Equatable, Sendable {
    case mix(Nym_Vpn_MixConnectedStateDetails)
    case wg(Nym_Vpn_WgConnectedStateDetails)

  }

  init() {}
}

struct Nym_Vpn_Dns: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Url: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Inspired by
/// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent
/// Forward slashes '/' are not valid
struct Nym_Vpn_UserAgent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Example:
  ///    nym-vpn-app
  ///    nym-vpnd
  var application: String = String()

  /// Format: version[-optional] [(daemon version[-optional])]
  /// Example:
  ///    0.1.8
  ///    0.1.8-debug (0.1.6)
  ///    0.2.1-fdroid
  var version: String = String()

  /// Format: OS; OS version; CPU
  /// Example:
  ///    Windows NT 6.1; Win64; x64
  ///    Macintosh; Intel Mac OS X 14.6.1
  ///    iPad; U; CPU OS 3_2 like Mac OS X; en-us
  var platform: String = String()

  /// Format: git hash [(daemon git hash)]
  /// Commit hash should be at least 7 characters long
  /// Example:
  ///    4h9fk59 (4kdufle)
  ///    4h9fk59
  var gitCommit: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_DenomDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: String = String()

  var display: String = String()

  var displayExponent: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ChainDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bech32AccountPrefix: String = String()

  var mixDenom: Nym_Vpn_DenomDetails {
    get {return _mixDenom ?? Nym_Vpn_DenomDetails()}
    set {_mixDenom = newValue}
  }
  /// Returns true if `mixDenom` has been explicitly set.
  var hasMixDenom: Bool {return self._mixDenom != nil}
  /// Clears the value of `mixDenom`. Subsequent reads from it will return its default value.
  mutating func clearMixDenom() {self._mixDenom = nil}

  var stakeDenom: Nym_Vpn_DenomDetails {
    get {return _stakeDenom ?? Nym_Vpn_DenomDetails()}
    set {_stakeDenom = newValue}
  }
  /// Returns true if `stakeDenom` has been explicitly set.
  var hasStakeDenom: Bool {return self._stakeDenom != nil}
  /// Clears the value of `stakeDenom`. Subsequent reads from it will return its default value.
  mutating func clearStakeDenom() {self._stakeDenom = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mixDenom: Nym_Vpn_DenomDetails? = nil
  fileprivate var _stakeDenom: Nym_Vpn_DenomDetails? = nil
}

struct Nym_Vpn_NymContracts: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mixnetContractAddress: String {
    get {return _mixnetContractAddress ?? String()}
    set {_mixnetContractAddress = newValue}
  }
  /// Returns true if `mixnetContractAddress` has been explicitly set.
  var hasMixnetContractAddress: Bool {return self._mixnetContractAddress != nil}
  /// Clears the value of `mixnetContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearMixnetContractAddress() {self._mixnetContractAddress = nil}

  var vestingContractAddress: String {
    get {return _vestingContractAddress ?? String()}
    set {_vestingContractAddress = newValue}
  }
  /// Returns true if `vestingContractAddress` has been explicitly set.
  var hasVestingContractAddress: Bool {return self._vestingContractAddress != nil}
  /// Clears the value of `vestingContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearVestingContractAddress() {self._vestingContractAddress = nil}

  var ecashContractAddress: String {
    get {return _ecashContractAddress ?? String()}
    set {_ecashContractAddress = newValue}
  }
  /// Returns true if `ecashContractAddress` has been explicitly set.
  var hasEcashContractAddress: Bool {return self._ecashContractAddress != nil}
  /// Clears the value of `ecashContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearEcashContractAddress() {self._ecashContractAddress = nil}

  var groupContractAddress: String {
    get {return _groupContractAddress ?? String()}
    set {_groupContractAddress = newValue}
  }
  /// Returns true if `groupContractAddress` has been explicitly set.
  var hasGroupContractAddress: Bool {return self._groupContractAddress != nil}
  /// Clears the value of `groupContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearGroupContractAddress() {self._groupContractAddress = nil}

  var multisigContractAddress: String {
    get {return _multisigContractAddress ?? String()}
    set {_multisigContractAddress = newValue}
  }
  /// Returns true if `multisigContractAddress` has been explicitly set.
  var hasMultisigContractAddress: Bool {return self._multisigContractAddress != nil}
  /// Clears the value of `multisigContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearMultisigContractAddress() {self._multisigContractAddress = nil}

  var coconutDkgContractAddress: String {
    get {return _coconutDkgContractAddress ?? String()}
    set {_coconutDkgContractAddress = newValue}
  }
  /// Returns true if `coconutDkgContractAddress` has been explicitly set.
  var hasCoconutDkgContractAddress: Bool {return self._coconutDkgContractAddress != nil}
  /// Clears the value of `coconutDkgContractAddress`. Subsequent reads from it will return its default value.
  mutating func clearCoconutDkgContractAddress() {self._coconutDkgContractAddress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mixnetContractAddress: String? = nil
  fileprivate var _vestingContractAddress: String? = nil
  fileprivate var _ecashContractAddress: String? = nil
  fileprivate var _groupContractAddress: String? = nil
  fileprivate var _multisigContractAddress: String? = nil
  fileprivate var _coconutDkgContractAddress: String? = nil
}

struct Nym_Vpn_NymNetworkDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkName: String = String()

  var chainDetails: Nym_Vpn_ChainDetails {
    get {return _chainDetails ?? Nym_Vpn_ChainDetails()}
    set {_chainDetails = newValue}
  }
  /// Returns true if `chainDetails` has been explicitly set.
  var hasChainDetails: Bool {return self._chainDetails != nil}
  /// Clears the value of `chainDetails`. Subsequent reads from it will return its default value.
  mutating func clearChainDetails() {self._chainDetails = nil}

  var endpoints: [Nym_Vpn_ValidatorDetails] = []

  var contracts: Nym_Vpn_NymContracts {
    get {return _contracts ?? Nym_Vpn_NymContracts()}
    set {_contracts = newValue}
  }
  /// Returns true if `contracts` has been explicitly set.
  var hasContracts: Bool {return self._contracts != nil}
  /// Clears the value of `contracts`. Subsequent reads from it will return its default value.
  mutating func clearContracts() {self._contracts = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chainDetails: Nym_Vpn_ChainDetails? = nil
  fileprivate var _contracts: Nym_Vpn_NymContracts? = nil
}

struct Nym_Vpn_NymVpnNetworkDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymVpnApiURL: Nym_Vpn_Url {
    get {return _nymVpnApiURL ?? Nym_Vpn_Url()}
    set {_nymVpnApiURL = newValue}
  }
  /// Returns true if `nymVpnApiURL` has been explicitly set.
  var hasNymVpnApiURL: Bool {return self._nymVpnApiURL != nil}
  /// Clears the value of `nymVpnApiURL`. Subsequent reads from it will return its default value.
  mutating func clearNymVpnApiURL() {self._nymVpnApiURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nymVpnApiURL: Nym_Vpn_Url? = nil
}

struct Nym_Vpn_AccountManagement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signUp: Nym_Vpn_Url {
    get {return _signUp ?? Nym_Vpn_Url()}
    set {_signUp = newValue}
  }
  /// Returns true if `signUp` has been explicitly set.
  var hasSignUp: Bool {return self._signUp != nil}
  /// Clears the value of `signUp`. Subsequent reads from it will return its default value.
  mutating func clearSignUp() {self._signUp = nil}

  var signIn: Nym_Vpn_Url {
    get {return _signIn ?? Nym_Vpn_Url()}
    set {_signIn = newValue}
  }
  /// Returns true if `signIn` has been explicitly set.
  var hasSignIn: Bool {return self._signIn != nil}
  /// Clears the value of `signIn`. Subsequent reads from it will return its default value.
  mutating func clearSignIn() {self._signIn = nil}

  var account: Nym_Vpn_Url {
    get {return _account ?? Nym_Vpn_Url()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signUp: Nym_Vpn_Url? = nil
  fileprivate var _signIn: Nym_Vpn_Url? = nil
  fileprivate var _account: Nym_Vpn_Url? = nil
}

struct Nym_Vpn_ValidatorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nyxdURL: Nym_Vpn_Url {
    get {return _nyxdURL ?? Nym_Vpn_Url()}
    set {_nyxdURL = newValue}
  }
  /// Returns true if `nyxdURL` has been explicitly set.
  var hasNyxdURL: Bool {return self._nyxdURL != nil}
  /// Clears the value of `nyxdURL`. Subsequent reads from it will return its default value.
  mutating func clearNyxdURL() {self._nyxdURL = nil}

  var websocketURL: Nym_Vpn_Url {
    get {return _websocketURL ?? Nym_Vpn_Url()}
    set {_websocketURL = newValue}
  }
  /// Returns true if `websocketURL` has been explicitly set.
  var hasWebsocketURL: Bool {return self._websocketURL != nil}
  /// Clears the value of `websocketURL`. Subsequent reads from it will return its default value.
  mutating func clearWebsocketURL() {self._websocketURL = nil}

  var apiURL: Nym_Vpn_Url {
    get {return _apiURL ?? Nym_Vpn_Url()}
    set {_apiURL = newValue}
  }
  /// Returns true if `apiURL` has been explicitly set.
  var hasApiURL: Bool {return self._apiURL != nil}
  /// Clears the value of `apiURL`. Subsequent reads from it will return its default value.
  mutating func clearApiURL() {self._apiURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nyxdURL: Nym_Vpn_Url? = nil
  fileprivate var _websocketURL: Nym_Vpn_Url? = nil
  fileprivate var _apiURL: Nym_Vpn_Url? = nil
}

struct Nym_Vpn_InfoResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var buildTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._buildTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._buildTimestamp = newValue}
  }
  /// Returns true if `buildTimestamp` has been explicitly set.
  var hasBuildTimestamp: Bool {return _storage._buildTimestamp != nil}
  /// Clears the value of `buildTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearBuildTimestamp() {_uniqueStorage()._buildTimestamp = nil}

  var triple: String {
    get {return _storage._triple}
    set {_uniqueStorage()._triple = newValue}
  }

  var platform: String {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  var gitCommit: String {
    get {return _storage._gitCommit}
    set {_uniqueStorage()._gitCommit = newValue}
  }

  var nymNetwork: Nym_Vpn_NymNetworkDetails {
    get {return _storage._nymNetwork ?? Nym_Vpn_NymNetworkDetails()}
    set {_uniqueStorage()._nymNetwork = newValue}
  }
  /// Returns true if `nymNetwork` has been explicitly set.
  var hasNymNetwork: Bool {return _storage._nymNetwork != nil}
  /// Clears the value of `nymNetwork`. Subsequent reads from it will return its default value.
  mutating func clearNymNetwork() {_uniqueStorage()._nymNetwork = nil}

  var nymVpnNetwork: Nym_Vpn_NymVpnNetworkDetails {
    get {return _storage._nymVpnNetwork ?? Nym_Vpn_NymVpnNetworkDetails()}
    set {_uniqueStorage()._nymVpnNetwork = newValue}
  }
  /// Returns true if `nymVpnNetwork` has been explicitly set.
  var hasNymVpnNetwork: Bool {return _storage._nymVpnNetwork != nil}
  /// Clears the value of `nymVpnNetwork`. Subsequent reads from it will return its default value.
  mutating func clearNymVpnNetwork() {_uniqueStorage()._nymVpnNetwork = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Nym_Vpn_SetNetworkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var network: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_SetNetworkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Nym_Vpn_SetNetworkRequestError {
    get {return _error ?? Nym_Vpn_SetNetworkRequestError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_SetNetworkRequestError? = nil
}

struct Nym_Vpn_SetNetworkRequestError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType = .unspecified

  /// Internal message for logging and debugging
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SetNetworkRequestErrorType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unspecified // = 0

    /// Unspecified internal error
    case `internal` // = 1

    /// The network name provided is not valid
    case invalidNetworkName // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      case 2: self = .invalidNetworkName
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .invalidNetworkName: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType] = [
      .unspecified,
      .internal,
      .invalidNetworkName,
    ]

  }

  init() {}
}

struct Nym_Vpn_SystemMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var message: String = String()

  var properties: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_NetworkCompatibility: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var core: String = String()

  var ios: String = String()

  var macos: String = String()

  var tauri: String = String()

  var android: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetSystemMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [Nym_Vpn_SystemMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetNetworkCompatibilityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: Nym_Vpn_NetworkCompatibility {
    get {return _messages ?? Nym_Vpn_NetworkCompatibility()}
    set {_messages = newValue}
  }
  /// Returns true if `messages` has been explicitly set.
  var hasMessages: Bool {return self._messages != nil}
  /// Clears the value of `messages`. Subsequent reads from it will return its default value.
  mutating func clearMessages() {self._messages = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _messages: Nym_Vpn_NetworkCompatibility? = nil
}

struct Nym_Vpn_GetFeatureFlagsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var flags: Dictionary<String,String> = [:]

  var groups: Dictionary<String,Nym_Vpn_FeatureFlagGroup> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_FeatureFlagGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_Threshold: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var minPerformance: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ConnectRequestError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_ConnectRequestError.ConnectRequestErrorType = .unspecified

  /// Internal message for logging and debugging
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ConnectRequestErrorType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unspecified // = 0

    /// Unspecified internal error
    case `internal` // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internal: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_ConnectRequestError.ConnectRequestErrorType] = [
      .unspecified,
      .internal,
    ]

  }

  init() {}
}

struct Nym_Vpn_ConnectRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: Nym_Vpn_EntryNode {
    get {return _storage._entry ?? Nym_Vpn_EntryNode()}
    set {_uniqueStorage()._entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  var hasEntry: Bool {return _storage._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  mutating func clearEntry() {_uniqueStorage()._entry = nil}

  var exit: Nym_Vpn_ExitNode {
    get {return _storage._exit ?? Nym_Vpn_ExitNode()}
    set {_uniqueStorage()._exit = newValue}
  }
  /// Returns true if `exit` has been explicitly set.
  var hasExit: Bool {return _storage._exit != nil}
  /// Clears the value of `exit`. Subsequent reads from it will return its default value.
  mutating func clearExit() {_uniqueStorage()._exit = nil}

  var dns: Nym_Vpn_Dns {
    get {return _storage._dns ?? Nym_Vpn_Dns()}
    set {_uniqueStorage()._dns = newValue}
  }
  /// Returns true if `dns` has been explicitly set.
  var hasDns: Bool {return _storage._dns != nil}
  /// Clears the value of `dns`. Subsequent reads from it will return its default value.
  mutating func clearDns() {_uniqueStorage()._dns = nil}

  var disableRouting: Bool {
    get {return _storage._disableRouting}
    set {_uniqueStorage()._disableRouting = newValue}
  }

  var enableTwoHop: Bool {
    get {return _storage._enableTwoHop}
    set {_uniqueStorage()._enableTwoHop = newValue}
  }

  var netstack: Bool {
    get {return _storage._netstack}
    set {_uniqueStorage()._netstack = newValue}
  }

  var disablePoissonRate: Bool {
    get {return _storage._disablePoissonRate}
    set {_uniqueStorage()._disablePoissonRate = newValue}
  }

  var disableBackgroundCoverTraffic: Bool {
    get {return _storage._disableBackgroundCoverTraffic}
    set {_uniqueStorage()._disableBackgroundCoverTraffic = newValue}
  }

  var enableCredentialsMode: Bool {
    get {return _storage._enableCredentialsMode}
    set {_uniqueStorage()._enableCredentialsMode = newValue}
  }

  var userAgent: Nym_Vpn_UserAgent {
    get {return _storage._userAgent ?? Nym_Vpn_UserAgent()}
    set {_uniqueStorage()._userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return _storage._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {_uniqueStorage()._userAgent = nil}

  /// Optional thresholds
  var minMixnodePerformance: Nym_Vpn_Threshold {
    get {return _storage._minMixnodePerformance ?? Nym_Vpn_Threshold()}
    set {_uniqueStorage()._minMixnodePerformance = newValue}
  }
  /// Returns true if `minMixnodePerformance` has been explicitly set.
  var hasMinMixnodePerformance: Bool {return _storage._minMixnodePerformance != nil}
  /// Clears the value of `minMixnodePerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnodePerformance() {_uniqueStorage()._minMixnodePerformance = nil}

  var minGatewayMixnetPerformance: Nym_Vpn_Threshold {
    get {return _storage._minGatewayMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_uniqueStorage()._minGatewayMixnetPerformance = newValue}
  }
  /// Returns true if `minGatewayMixnetPerformance` has been explicitly set.
  var hasMinGatewayMixnetPerformance: Bool {return _storage._minGatewayMixnetPerformance != nil}
  /// Clears the value of `minGatewayMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinGatewayMixnetPerformance() {_uniqueStorage()._minGatewayMixnetPerformance = nil}

  var minGatewayVpnPerformance: Nym_Vpn_Threshold {
    get {return _storage._minGatewayVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_uniqueStorage()._minGatewayVpnPerformance = newValue}
  }
  /// Returns true if `minGatewayVpnPerformance` has been explicitly set.
  var hasMinGatewayVpnPerformance: Bool {return _storage._minGatewayVpnPerformance != nil}
  /// Clears the value of `minGatewayVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinGatewayVpnPerformance() {_uniqueStorage()._minGatewayVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Nym_Vpn_ConnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var error: Nym_Vpn_ConnectRequestError {
    get {return _error ?? Nym_Vpn_ConnectRequestError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Nym_Vpn_ConnectRequestError? = nil
}

struct Nym_Vpn_DisconnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AsEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canConnect: Bool = false

  var canRoute: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_AsExit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canConnect: Bool = false

  var canRouteIpV4: Bool = false

  var canRouteIpV6: Bool = false

  var canRouteIpExternalV4: Bool = false

  var canRouteIpExternalV6: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_WgProbeResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var canRegister: Bool = false

  var canHandshake: Bool = false

  var canResolveDns: Bool = false

  var pingHostsPerformance: Float = 0

  var pingIpsPerformance: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ProbeOutcome: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var asEntry: Nym_Vpn_AsEntry {
    get {return _asEntry ?? Nym_Vpn_AsEntry()}
    set {_asEntry = newValue}
  }
  /// Returns true if `asEntry` has been explicitly set.
  var hasAsEntry: Bool {return self._asEntry != nil}
  /// Clears the value of `asEntry`. Subsequent reads from it will return its default value.
  mutating func clearAsEntry() {self._asEntry = nil}

  var asExit: Nym_Vpn_AsExit {
    get {return _asExit ?? Nym_Vpn_AsExit()}
    set {_asExit = newValue}
  }
  /// Returns true if `asExit` has been explicitly set.
  var hasAsExit: Bool {return self._asExit != nil}
  /// Clears the value of `asExit`. Subsequent reads from it will return its default value.
  mutating func clearAsExit() {self._asExit = nil}

  var wg: Nym_Vpn_WgProbeResult {
    get {return _wg ?? Nym_Vpn_WgProbeResult()}
    set {_wg = newValue}
  }
  /// Returns true if `wg` has been explicitly set.
  var hasWg: Bool {return self._wg != nil}
  /// Clears the value of `wg`. Subsequent reads from it will return its default value.
  mutating func clearWg() {self._wg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _asEntry: Nym_Vpn_AsEntry? = nil
  fileprivate var _asExit: Nym_Vpn_AsExit? = nil
  fileprivate var _wg: Nym_Vpn_WgProbeResult? = nil
}

struct Nym_Vpn_Probe: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastUpdatedUtc: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastUpdatedUtc ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastUpdatedUtc = newValue}
  }
  /// Returns true if `lastUpdatedUtc` has been explicitly set.
  var hasLastUpdatedUtc: Bool {return self._lastUpdatedUtc != nil}
  /// Clears the value of `lastUpdatedUtc`. Subsequent reads from it will return its default value.
  mutating func clearLastUpdatedUtc() {self._lastUpdatedUtc = nil}

  var outcome: Nym_Vpn_ProbeOutcome {
    get {return _outcome ?? Nym_Vpn_ProbeOutcome()}
    set {_outcome = newValue}
  }
  /// Returns true if `outcome` has been explicitly set.
  var hasOutcome: Bool {return self._outcome != nil}
  /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
  mutating func clearOutcome() {self._outcome = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastUpdatedUtc: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _outcome: Nym_Vpn_ProbeOutcome? = nil
}

struct Nym_Vpn_GatewayResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Nym_Vpn_Gateway {
    get {return _storage._id ?? Nym_Vpn_Gateway()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var location: Nym_Vpn_Location {
    get {return _storage._location ?? Nym_Vpn_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var lastProbe: Nym_Vpn_Probe {
    get {return _storage._lastProbe ?? Nym_Vpn_Probe()}
    set {_uniqueStorage()._lastProbe = newValue}
  }
  /// Returns true if `lastProbe` has been explicitly set.
  var hasLastProbe: Bool {return _storage._lastProbe != nil}
  /// Clears the value of `lastProbe`. Subsequent reads from it will return its default value.
  mutating func clearLastProbe() {_uniqueStorage()._lastProbe = nil}

  var wgScore: Nym_Vpn_Score {
    get {return _storage._wgScore ?? .none}
    set {_uniqueStorage()._wgScore = newValue}
  }
  /// Returns true if `wgScore` has been explicitly set.
  var hasWgScore: Bool {return _storage._wgScore != nil}
  /// Clears the value of `wgScore`. Subsequent reads from it will return its default value.
  mutating func clearWgScore() {_uniqueStorage()._wgScore = nil}

  var mixnetScore: Nym_Vpn_Score {
    get {return _storage._mixnetScore ?? .none}
    set {_uniqueStorage()._mixnetScore = newValue}
  }
  /// Returns true if `mixnetScore` has been explicitly set.
  var hasMixnetScore: Bool {return _storage._mixnetScore != nil}
  /// Clears the value of `mixnetScore`. Subsequent reads from it will return its default value.
  mutating func clearMixnetScore() {_uniqueStorage()._mixnetScore = nil}

  var moniker: String {
    get {return _storage._moniker}
    set {_uniqueStorage()._moniker = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Nym_Vpn_ListGatewaysRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_GatewayType = .unspecified

  var userAgent: Nym_Vpn_UserAgent {
    get {return _userAgent ?? Nym_Vpn_UserAgent()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {self._userAgent = nil}

  /// Optional thresholds
  var minMixnetPerformance: Nym_Vpn_Threshold {
    get {return _minMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_minMixnetPerformance = newValue}
  }
  /// Returns true if `minMixnetPerformance` has been explicitly set.
  var hasMinMixnetPerformance: Bool {return self._minMixnetPerformance != nil}
  /// Clears the value of `minMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnetPerformance() {self._minMixnetPerformance = nil}

  var minVpnPerformance: Nym_Vpn_Threshold {
    get {return _minVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_minVpnPerformance = newValue}
  }
  /// Returns true if `minVpnPerformance` has been explicitly set.
  var hasMinVpnPerformance: Bool {return self._minVpnPerformance != nil}
  /// Clears the value of `minVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinVpnPerformance() {self._minVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userAgent: Nym_Vpn_UserAgent? = nil
  fileprivate var _minMixnetPerformance: Nym_Vpn_Threshold? = nil
  fileprivate var _minVpnPerformance: Nym_Vpn_Threshold? = nil
}

struct Nym_Vpn_ListGatewaysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gateways: [Nym_Vpn_GatewayResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_ListCountriesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Nym_Vpn_GatewayType = .unspecified

  var userAgent: Nym_Vpn_UserAgent {
    get {return _userAgent ?? Nym_Vpn_UserAgent()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {self._userAgent = nil}

  /// Optional thresholds
  var minMixnetPerformance: Nym_Vpn_Threshold {
    get {return _minMixnetPerformance ?? Nym_Vpn_Threshold()}
    set {_minMixnetPerformance = newValue}
  }
  /// Returns true if `minMixnetPerformance` has been explicitly set.
  var hasMinMixnetPerformance: Bool {return self._minMixnetPerformance != nil}
  /// Clears the value of `minMixnetPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinMixnetPerformance() {self._minMixnetPerformance = nil}

  var minVpnPerformance: Nym_Vpn_Threshold {
    get {return _minVpnPerformance ?? Nym_Vpn_Threshold()}
    set {_minVpnPerformance = newValue}
  }
  /// Returns true if `minVpnPerformance` has been explicitly set.
  var hasMinVpnPerformance: Bool {return self._minVpnPerformance != nil}
  /// Clears the value of `minVpnPerformance`. Subsequent reads from it will return its default value.
  mutating func clearMinVpnPerformance() {self._minVpnPerformance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userAgent: Nym_Vpn_UserAgent? = nil
  fileprivate var _minMixnetPerformance: Nym_Vpn_Threshold? = nil
  fileprivate var _minVpnPerformance: Nym_Vpn_Threshold? = nil
}

struct Nym_Vpn_ListCountriesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countries: [Nym_Vpn_Location] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountLinksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locale: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_GetAccountLinksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var res: Nym_Vpn_GetAccountLinksResponse.OneOf_Res? = nil

  var links: Nym_Vpn_AccountManagement {
    get {
      if case .links(let v)? = res {return v}
      return Nym_Vpn_AccountManagement()
    }
    set {res = .links(newValue)}
  }

  var error: Nym_Vpn_AccountError {
    get {
      if case .error(let v)? = res {return v}
      return Nym_Vpn_AccountError()
    }
    set {res = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Res: Equatable, Sendable {
    case links(Nym_Vpn_AccountManagement)
    case error(Nym_Vpn_AccountError)

  }

  init() {}
}

struct Nym_Vpn_ConnectionData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entryGateway: Nym_Vpn_Gateway {
    get {return _entryGateway ?? Nym_Vpn_Gateway()}
    set {_entryGateway = newValue}
  }
  /// Returns true if `entryGateway` has been explicitly set.
  var hasEntryGateway: Bool {return self._entryGateway != nil}
  /// Clears the value of `entryGateway`. Subsequent reads from it will return its default value.
  mutating func clearEntryGateway() {self._entryGateway = nil}

  var exitGateway: Nym_Vpn_Gateway {
    get {return _exitGateway ?? Nym_Vpn_Gateway()}
    set {_exitGateway = newValue}
  }
  /// Returns true if `exitGateway` has been explicitly set.
  var hasExitGateway: Bool {return self._exitGateway != nil}
  /// Clears the value of `exitGateway`. Subsequent reads from it will return its default value.
  mutating func clearExitGateway() {self._exitGateway = nil}

  var connectedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _connectedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_connectedAt = newValue}
  }
  /// Returns true if `connectedAt` has been explicitly set.
  var hasConnectedAt: Bool {return self._connectedAt != nil}
  /// Clears the value of `connectedAt`. Subsequent reads from it will return its default value.
  mutating func clearConnectedAt() {self._connectedAt = nil}

  var tunnel: Nym_Vpn_TunnelConnectionData {
    get {return _tunnel ?? Nym_Vpn_TunnelConnectionData()}
    set {_tunnel = newValue}
  }
  /// Returns true if `tunnel` has been explicitly set.
  var hasTunnel: Bool {return self._tunnel != nil}
  /// Clears the value of `tunnel`. Subsequent reads from it will return its default value.
  mutating func clearTunnel() {self._tunnel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entryGateway: Nym_Vpn_Gateway? = nil
  fileprivate var _exitGateway: Nym_Vpn_Gateway? = nil
  fileprivate var _connectedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _tunnel: Nym_Vpn_TunnelConnectionData? = nil
}

struct Nym_Vpn_MixnetConnectionData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nymAddress: Nym_Vpn_Address {
    get {return _nymAddress ?? Nym_Vpn_Address()}
    set {_nymAddress = newValue}
  }
  /// Returns true if `nymAddress` has been explicitly set.
  var hasNymAddress: Bool {return self._nymAddress != nil}
  /// Clears the value of `nymAddress`. Subsequent reads from it will return its default value.
  mutating func clearNymAddress() {self._nymAddress = nil}

  var exitIpr: Nym_Vpn_Address {
    get {return _exitIpr ?? Nym_Vpn_Address()}
    set {_exitIpr = newValue}
  }
  /// Returns true if `exitIpr` has been explicitly set.
  var hasExitIpr: Bool {return self._exitIpr != nil}
  /// Clears the value of `exitIpr`. Subsequent reads from it will return its default value.
  mutating func clearExitIpr() {self._exitIpr = nil}

  var ipv4: String = String()

  var ipv6: String = String()

  var entryIp: String = String()

  var exitIp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nymAddress: Nym_Vpn_Address? = nil
  fileprivate var _exitIpr: Nym_Vpn_Address? = nil
}

struct Nym_Vpn_WireguardConnectionData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entry: Nym_Vpn_WireguardNode {
    get {return _entry ?? Nym_Vpn_WireguardNode()}
    set {_entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  var hasEntry: Bool {return self._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  mutating func clearEntry() {self._entry = nil}

  var exit: Nym_Vpn_WireguardNode {
    get {return _exit ?? Nym_Vpn_WireguardNode()}
    set {_exit = newValue}
  }
  /// Returns true if `exit` has been explicitly set.
  var hasExit: Bool {return self._exit != nil}
  /// Clears the value of `exit`. Subsequent reads from it will return its default value.
  mutating func clearExit() {self._exit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entry: Nym_Vpn_WireguardNode? = nil
  fileprivate var _exit: Nym_Vpn_WireguardNode? = nil
}

struct Nym_Vpn_WireguardNode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var endpoint: String = String()

  var publicKey: String = String()

  var privateIpv4: String = String()

  var privateIpv6: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Nym_Vpn_TunnelConnectionData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Nym_Vpn_TunnelConnectionData.OneOf_State? = nil

  var mixnet: Nym_Vpn_TunnelConnectionData.Mixnet {
    get {
      if case .mixnet(let v)? = state {return v}
      return Nym_Vpn_TunnelConnectionData.Mixnet()
    }
    set {state = .mixnet(newValue)}
  }

  var wireguard: Nym_Vpn_TunnelConnectionData.Wireguard {
    get {
      if case .wireguard(let v)? = state {return v}
      return Nym_Vpn_TunnelConnectionData.Wireguard()
    }
    set {state = .wireguard(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_State: Equatable, Sendable {
    case mixnet(Nym_Vpn_TunnelConnectionData.Mixnet)
    case wireguard(Nym_Vpn_TunnelConnectionData.Wireguard)

  }

  struct Mixnet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Nym_Vpn_MixnetConnectionData {
      get {return _data ?? Nym_Vpn_MixnetConnectionData()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating func clearData() {self._data = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _data: Nym_Vpn_MixnetConnectionData? = nil
  }

  struct Wireguard: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Nym_Vpn_WireguardConnectionData {
      get {return _data ?? Nym_Vpn_WireguardConnectionData()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating func clearData() {self._data = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _data: Nym_Vpn_WireguardConnectionData? = nil
  }

  init() {}
}

struct Nym_Vpn_TunnelState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Nym_Vpn_TunnelState.OneOf_State? = nil

  var disconnected: Nym_Vpn_TunnelState.Disconnected {
    get {
      if case .disconnected(let v)? = state {return v}
      return Nym_Vpn_TunnelState.Disconnected()
    }
    set {state = .disconnected(newValue)}
  }

  var connecting: Nym_Vpn_TunnelState.Connecting {
    get {
      if case .connecting(let v)? = state {return v}
      return Nym_Vpn_TunnelState.Connecting()
    }
    set {state = .connecting(newValue)}
  }

  var connected: Nym_Vpn_TunnelState.Connected {
    get {
      if case .connected(let v)? = state {return v}
      return Nym_Vpn_TunnelState.Connected()
    }
    set {state = .connected(newValue)}
  }

  var disconnecting: Nym_Vpn_TunnelState.Disconnecting {
    get {
      if case .disconnecting(let v)? = state {return v}
      return Nym_Vpn_TunnelState.Disconnecting()
    }
    set {state = .disconnecting(newValue)}
  }

  var error: Nym_Vpn_TunnelState.Error {
    get {
      if case .error(let v)? = state {return v}
      return Nym_Vpn_TunnelState.Error()
    }
    set {state = .error(newValue)}
  }

  var offline: Nym_Vpn_TunnelState.Offline {
    get {
      if case .offline(let v)? = state {return v}
      return Nym_Vpn_TunnelState.Offline()
    }
    set {state = .offline(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_State: Equatable, Sendable {
    case disconnected(Nym_Vpn_TunnelState.Disconnected)
    case connecting(Nym_Vpn_TunnelState.Connecting)
    case connected(Nym_Vpn_TunnelState.Connected)
    case disconnecting(Nym_Vpn_TunnelState.Disconnecting)
    case error(Nym_Vpn_TunnelState.Error)
    case offline(Nym_Vpn_TunnelState.Offline)

  }

  enum BaseErrorStateReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case firewall // = 0
    case routing // = 1
    case dns // = 2
    case tunDevice // = 3
    case tunnelProvider // = 4
    case sameEntryAndExitGateway // = 5
    case invalidEntryGatewayCountry // = 6
    case invalidExitGatewayCountry // = 7
    case badBandwidthIncrease // = 8
    case duplicateTunFd // = 9
    case `internal` // = 10
    case resolveGatewayAddrs // = 11
    case startLocalDnsResolver // = 12
    case UNRECOGNIZED(Int)

    init() {
      self = .firewall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .firewall
      case 1: self = .routing
      case 2: self = .dns
      case 3: self = .tunDevice
      case 4: self = .tunnelProvider
      case 5: self = .sameEntryAndExitGateway
      case 6: self = .invalidEntryGatewayCountry
      case 7: self = .invalidExitGatewayCountry
      case 8: self = .badBandwidthIncrease
      case 9: self = .duplicateTunFd
      case 10: self = .internal
      case 11: self = .resolveGatewayAddrs
      case 12: self = .startLocalDnsResolver
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .firewall: return 0
      case .routing: return 1
      case .dns: return 2
      case .tunDevice: return 3
      case .tunnelProvider: return 4
      case .sameEntryAndExitGateway: return 5
      case .invalidEntryGatewayCountry: return 6
      case .invalidExitGatewayCountry: return 7
      case .badBandwidthIncrease: return 8
      case .duplicateTunFd: return 9
      case .internal: return 10
      case .resolveGatewayAddrs: return 11
      case .startLocalDnsResolver: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_TunnelState.BaseErrorStateReason] = [
      .firewall,
      .routing,
      .dns,
      .tunDevice,
      .tunnelProvider,
      .sameEntryAndExitGateway,
      .invalidEntryGatewayCountry,
      .invalidExitGatewayCountry,
      .badBandwidthIncrease,
      .duplicateTunFd,
      .internal,
      .resolveGatewayAddrs,
      .startLocalDnsResolver,
    ]

  }

  enum ActionAfterDisconnect: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case nothing // = 0
    case error // = 1
    case reconnect // = 2
    case offline // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .nothing
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nothing
      case 1: self = .error
      case 2: self = .reconnect
      case 3: self = .offline
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .nothing: return 0
      case .error: return 1
      case .reconnect: return 2
      case .offline: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_TunnelState.ActionAfterDisconnect] = [
      .nothing,
      .error,
      .reconnect,
      .offline,
    ]

  }

  struct Disconnected: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Connecting: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var connectionData: Nym_Vpn_ConnectionData {
      get {return _connectionData ?? Nym_Vpn_ConnectionData()}
      set {_connectionData = newValue}
    }
    /// Returns true if `connectionData` has been explicitly set.
    var hasConnectionData: Bool {return self._connectionData != nil}
    /// Clears the value of `connectionData`. Subsequent reads from it will return its default value.
    mutating func clearConnectionData() {self._connectionData = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _connectionData: Nym_Vpn_ConnectionData? = nil
  }

  struct Connected: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var connectionData: Nym_Vpn_ConnectionData {
      get {return _connectionData ?? Nym_Vpn_ConnectionData()}
      set {_connectionData = newValue}
    }
    /// Returns true if `connectionData` has been explicitly set.
    var hasConnectionData: Bool {return self._connectionData != nil}
    /// Clears the value of `connectionData`. Subsequent reads from it will return its default value.
    mutating func clearConnectionData() {self._connectionData = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _connectionData: Nym_Vpn_ConnectionData? = nil
  }

  struct Disconnecting: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var afterDisconnect: Nym_Vpn_TunnelState.ActionAfterDisconnect = .nothing

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var errorStateReason: Nym_Vpn_TunnelState.Error.OneOf_ErrorStateReason? = nil

    var baseReason: Nym_Vpn_TunnelState.BaseErrorStateReason {
      get {
        if case .baseReason(let v)? = errorStateReason {return v}
        return .firewall
      }
      set {errorStateReason = .baseReason(newValue)}
    }

    var syncAccount: Nym_Vpn_SyncAccountError {
      get {
        if case .syncAccount(let v)? = errorStateReason {return v}
        return Nym_Vpn_SyncAccountError()
      }
      set {errorStateReason = .syncAccount(newValue)}
    }

    var syncDevice: Nym_Vpn_SyncDeviceError {
      get {
        if case .syncDevice(let v)? = errorStateReason {return v}
        return Nym_Vpn_SyncDeviceError()
      }
      set {errorStateReason = .syncDevice(newValue)}
    }

    var registerDevice: Nym_Vpn_RegisterDeviceError {
      get {
        if case .registerDevice(let v)? = errorStateReason {return v}
        return Nym_Vpn_RegisterDeviceError()
      }
      set {errorStateReason = .registerDevice(newValue)}
    }

    var requestZkNym: Nym_Vpn_RequestZkNymError {
      get {
        if case .requestZkNym(let v)? = errorStateReason {return v}
        return Nym_Vpn_RequestZkNymError()
      }
      set {errorStateReason = .requestZkNym(newValue)}
    }

    var requestZkNymBundle: Nym_Vpn_RequestZkNymBundle {
      get {
        if case .requestZkNymBundle(let v)? = errorStateReason {return v}
        return Nym_Vpn_RequestZkNymBundle()
      }
      set {errorStateReason = .requestZkNymBundle(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ErrorStateReason: Equatable, Sendable {
      case baseReason(Nym_Vpn_TunnelState.BaseErrorStateReason)
      case syncAccount(Nym_Vpn_SyncAccountError)
      case syncDevice(Nym_Vpn_SyncDeviceError)
      case registerDevice(Nym_Vpn_RegisterDeviceError)
      case requestZkNym(Nym_Vpn_RequestZkNymError)
      case requestZkNymBundle(Nym_Vpn_RequestZkNymBundle)

    }

    init() {}
  }

  struct Offline: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var reconnect: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Nym_Vpn_TunnelEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Nym_Vpn_TunnelEvent.OneOf_Event? = nil

  var tunnelState: Nym_Vpn_TunnelState {
    get {
      if case .tunnelState(let v)? = event {return v}
      return Nym_Vpn_TunnelState()
    }
    set {event = .tunnelState(newValue)}
  }

  var mixnetEvent: Nym_Vpn_MixnetEvent {
    get {
      if case .mixnetEvent(let v)? = event {return v}
      return Nym_Vpn_MixnetEvent()
    }
    set {event = .mixnetEvent(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case tunnelState(Nym_Vpn_TunnelState)
    case mixnetEvent(Nym_Vpn_MixnetEvent)

  }

  init() {}
}

struct Nym_Vpn_MixnetEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Nym_Vpn_MixnetEvent.OneOf_Event? = nil

  var bandwidthEvent: Nym_Vpn_MixnetEvent.BandwidthEvent {
    get {
      if case .bandwidthEvent(let v)? = event {return v}
      return Nym_Vpn_MixnetEvent.BandwidthEvent()
    }
    set {event = .bandwidthEvent(newValue)}
  }

  var connectionEvent: Nym_Vpn_MixnetEvent.ConnectionEvent {
    get {
      if case .connectionEvent(let v)? = event {return v}
      return .entryGatewayDown
    }
    set {event = .connectionEvent(newValue)}
  }

  var connectionStatisticsEvent: Nym_Vpn_MixnetEvent.ConnectionStatisticsEvent {
    get {
      if case .connectionStatisticsEvent(let v)? = event {return v}
      return Nym_Vpn_MixnetEvent.ConnectionStatisticsEvent()
    }
    set {event = .connectionStatisticsEvent(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case bandwidthEvent(Nym_Vpn_MixnetEvent.BandwidthEvent)
    case connectionEvent(Nym_Vpn_MixnetEvent.ConnectionEvent)
    case connectionStatisticsEvent(Nym_Vpn_MixnetEvent.ConnectionStatisticsEvent)

  }

  enum ConnectionEvent: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case entryGatewayDown // = 0
    case exitGatewayDownIpv4 // = 1
    case exitGatewayDownIpv6 // = 2
    case exitGatewayRoutingErrorIpv4 // = 3
    case exitGatewayRoutingErrorIpv6 // = 4
    case connectedIpv4 // = 5
    case connectedIpv6 // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .entryGatewayDown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .entryGatewayDown
      case 1: self = .exitGatewayDownIpv4
      case 2: self = .exitGatewayDownIpv6
      case 3: self = .exitGatewayRoutingErrorIpv4
      case 4: self = .exitGatewayRoutingErrorIpv6
      case 5: self = .connectedIpv4
      case 6: self = .connectedIpv6
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .entryGatewayDown: return 0
      case .exitGatewayDownIpv4: return 1
      case .exitGatewayDownIpv6: return 2
      case .exitGatewayRoutingErrorIpv4: return 3
      case .exitGatewayRoutingErrorIpv6: return 4
      case .connectedIpv4: return 5
      case .connectedIpv6: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Nym_Vpn_MixnetEvent.ConnectionEvent] = [
      .entryGatewayDown,
      .exitGatewayDownIpv4,
      .exitGatewayDownIpv6,
      .exitGatewayRoutingErrorIpv4,
      .exitGatewayRoutingErrorIpv6,
      .connectedIpv4,
      .connectedIpv6,
    ]

  }

  struct BandwidthEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var event: Nym_Vpn_MixnetEvent.BandwidthEvent.OneOf_Event? = nil

    var noBandwidth: Nym_Vpn_MixnetEvent.BandwidthEvent.NoBandwidth {
      get {
        if case .noBandwidth(let v)? = event {return v}
        return Nym_Vpn_MixnetEvent.BandwidthEvent.NoBandwidth()
      }
      set {event = .noBandwidth(newValue)}
    }

    var remainingBandwidth: Nym_Vpn_MixnetEvent.BandwidthEvent.RemainingBandwidth {
      get {
        if case .remainingBandwidth(let v)? = event {return v}
        return Nym_Vpn_MixnetEvent.BandwidthEvent.RemainingBandwidth()
      }
      set {event = .remainingBandwidth(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Event: Equatable, Sendable {
      case noBandwidth(Nym_Vpn_MixnetEvent.BandwidthEvent.NoBandwidth)
      case remainingBandwidth(Nym_Vpn_MixnetEvent.BandwidthEvent.RemainingBandwidth)

    }

    struct NoBandwidth: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RemainingBandwidth: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Int64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct SphinxPacketRates: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var realPacketsSent: Double {
      get {return _storage._realPacketsSent}
      set {_uniqueStorage()._realPacketsSent = newValue}
    }

    var realPacketsSentSize: Double {
      get {return _storage._realPacketsSentSize}
      set {_uniqueStorage()._realPacketsSentSize = newValue}
    }

    var coverPacketsSent: Double {
      get {return _storage._coverPacketsSent}
      set {_uniqueStorage()._coverPacketsSent = newValue}
    }

    var coverPacketsSentSize: Double {
      get {return _storage._coverPacketsSentSize}
      set {_uniqueStorage()._coverPacketsSentSize = newValue}
    }

    var realPacketsReceived: Double {
      get {return _storage._realPacketsReceived}
      set {_uniqueStorage()._realPacketsReceived = newValue}
    }

    var realPacketsReceivedSize: Double {
      get {return _storage._realPacketsReceivedSize}
      set {_uniqueStorage()._realPacketsReceivedSize = newValue}
    }

    var coverPacketsReceived: Double {
      get {return _storage._coverPacketsReceived}
      set {_uniqueStorage()._coverPacketsReceived = newValue}
    }

    var coverPacketsReceivedSize: Double {
      get {return _storage._coverPacketsReceivedSize}
      set {_uniqueStorage()._coverPacketsReceivedSize = newValue}
    }

    var totalAcksReceived: Double {
      get {return _storage._totalAcksReceived}
      set {_uniqueStorage()._totalAcksReceived = newValue}
    }

    var totalAcksReceivedSize: Double {
      get {return _storage._totalAcksReceivedSize}
      set {_uniqueStorage()._totalAcksReceivedSize = newValue}
    }

    var realAcksReceived: Double {
      get {return _storage._realAcksReceived}
      set {_uniqueStorage()._realAcksReceived = newValue}
    }

    var realAcksReceivedSize: Double {
      get {return _storage._realAcksReceivedSize}
      set {_uniqueStorage()._realAcksReceivedSize = newValue}
    }

    var coverAcksReceived: Double {
      get {return _storage._coverAcksReceived}
      set {_uniqueStorage()._coverAcksReceived = newValue}
    }

    var coverAcksReceivedSize: Double {
      get {return _storage._coverAcksReceivedSize}
      set {_uniqueStorage()._coverAcksReceivedSize = newValue}
    }

    var realPacketsQueued: Double {
      get {return _storage._realPacketsQueued}
      set {_uniqueStorage()._realPacketsQueued = newValue}
    }

    var retransmissionsQueued: Double {
      get {return _storage._retransmissionsQueued}
      set {_uniqueStorage()._retransmissionsQueued = newValue}
    }

    var replySurbsQueued: Double {
      get {return _storage._replySurbsQueued}
      set {_uniqueStorage()._replySurbsQueued = newValue}
    }

    var additionalReplySurbsQueued: Double {
      get {return _storage._additionalReplySurbsQueued}
      set {_uniqueStorage()._additionalReplySurbsQueued = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ConnectionStatisticsEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rates: Nym_Vpn_MixnetEvent.SphinxPacketRates {
      get {return _rates ?? Nym_Vpn_MixnetEvent.SphinxPacketRates()}
      set {_rates = newValue}
    }
    /// Returns true if `rates` has been explicitly set.
    var hasRates: Bool {return self._rates != nil}
    /// Clears the value of `rates`. Subsequent reads from it will return its default value.
    mutating func clearRates() {self._rates = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _rates: Nym_Vpn_MixnetEvent.SphinxPacketRates? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nym.vpn"

extension Nym_Vpn_Score: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "LOW"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "HIGH"),
  ]
}

extension Nym_Vpn_GatewayType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GATEWAY_TYPE_UNSPECIFIED"),
    1: .same(proto: "MIXNET_ENTRY"),
    2: .same(proto: "MIXNET_EXIT"),
    3: .same(proto: "WG"),
  ]
}

extension Nym_Vpn_Gateway: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Gateway"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Gateway, rhs: Nym_Vpn_Gateway) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
    2: .standard(proto: "gateway_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nymAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gatewayID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nymAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.nymAddress, fieldNumber: 1)
    }
    if !self.gatewayID.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Address, rhs: Nym_Vpn_Address) -> Bool {
    if lhs.nymAddress != rhs.nymAddress {return false}
    if lhs.gatewayID != rhs.gatewayID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "two_letter_iso_country_code"),
    2: .same(proto: "latitude"),
    3: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.twoLetterIsoCountryCode) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.twoLetterIsoCountryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.twoLetterIsoCountryCode, fieldNumber: 1)
    }
    try { if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Location, rhs: Nym_Vpn_Location) -> Bool {
    if lhs.twoLetterIsoCountryCode != rhs.twoLetterIsoCountryCode {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_EntryNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntryNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateway"),
    2: .same(proto: "location"),
    3: .standard(proto: "random_low_latency"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .gateway(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .location(v)
        }
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .randomLowLatency(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .randomLowLatency(v)
        }
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.entryNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entryNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.entryNodeEnum {
    case .gateway?: try {
      guard case .gateway(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .location?: try {
      guard case .location(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .randomLowLatency?: try {
      guard case .randomLowLatency(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.entryNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_EntryNode, rhs: Nym_Vpn_EntryNode) -> Bool {
    if lhs.entryNodeEnum != rhs.entryNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ExitNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExitNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "gateway"),
    3: .same(proto: "location"),
    4: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_Address?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .address(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .address(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_Gateway?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .gateway(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .gateway(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_Location?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .location(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .location(v)
        }
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.exitNodeEnum {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.exitNodeEnum = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.exitNodeEnum {
    case .address?: try {
      guard case .address(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gateway?: try {
      guard case .gateway(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .location?: try {
      guard case .location(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .random?: try {
      guard case .random(let v)? = self.exitNodeEnum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ExitNode, rhs: Nym_Vpn_ExitNode) -> Bool {
    if lhs.exitNodeEnum != rhs.exitNodeEnum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MixConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
    2: .standard(proto: "exit_ipr"),
    3: .same(proto: "ipv4"),
    4: .same(proto: "ipv6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nymAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitIpr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipv4) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipv6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nymAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitIpr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ipv4.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv4, fieldNumber: 3)
    }
    if !self.ipv6.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv6, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixConnectedStateDetails, rhs: Nym_Vpn_MixConnectedStateDetails) -> Bool {
    if lhs._nymAddress != rhs._nymAddress {return false}
    if lhs._exitIpr != rhs._exitIpr {return false}
    if lhs.ipv4 != rhs.ipv4 {return false}
    if lhs.ipv6 != rhs.ipv6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WgConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WgConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_ipv4"),
    2: .standard(proto: "exit_ipv4"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entryIpv4) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exitIpv4) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entryIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.entryIpv4, fieldNumber: 1)
    }
    if !self.exitIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.exitIpv4, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WgConnectedStateDetails, rhs: Nym_Vpn_WgConnectedStateDetails) -> Bool {
    if lhs.entryIpv4 != rhs.entryIpv4 {return false}
    if lhs.exitIpv4 != rhs.exitIpv4 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectedStateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectedStateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mix"),
    2: .same(proto: "wg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_MixConnectedStateDetails?
        var hadOneofValue = false
        if let current = self.connectedStateDetails {
          hadOneofValue = true
          if case .mix(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectedStateDetails = .mix(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_WgConnectedStateDetails?
        var hadOneofValue = false
        if let current = self.connectedStateDetails {
          hadOneofValue = true
          if case .wg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.connectedStateDetails = .wg(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.connectedStateDetails {
    case .mix?: try {
      guard case .mix(let v)? = self.connectedStateDetails else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wg?: try {
      guard case .wg(let v)? = self.connectedStateDetails else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectedStateDetails, rhs: Nym_Vpn_ConnectedStateDetails) -> Bool {
    if lhs.connectedStateDetails != rhs.connectedStateDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Dns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Dns"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Dns, rhs: Nym_Vpn_Dns) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Url: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Url"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Url, rhs: Nym_Vpn_Url) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_UserAgent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserAgent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "application"),
    2: .same(proto: "version"),
    3: .same(proto: "platform"),
    4: .standard(proto: "git_commit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gitCommit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    if !self.gitCommit.isEmpty {
      try visitor.visitSingularStringField(value: self.gitCommit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_UserAgent, rhs: Nym_Vpn_UserAgent) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.version != rhs.version {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.gitCommit != rhs.gitCommit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DenomDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DenomDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "display"),
    3: .standard(proto: "display_exponent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.base) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.display) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.displayExponent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.base.isEmpty {
      try visitor.visitSingularStringField(value: self.base, fieldNumber: 1)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 2)
    }
    if self.displayExponent != 0 {
      try visitor.visitSingularUInt32Field(value: self.displayExponent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DenomDetails, rhs: Nym_Vpn_DenomDetails) -> Bool {
    if lhs.base != rhs.base {return false}
    if lhs.display != rhs.display {return false}
    if lhs.displayExponent != rhs.displayExponent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ChainDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bech32_account_prefix"),
    2: .standard(proto: "mix_denom"),
    3: .standard(proto: "stake_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bech32AccountPrefix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mixDenom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stakeDenom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bech32AccountPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.bech32AccountPrefix, fieldNumber: 1)
    }
    try { if let v = self._mixDenom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stakeDenom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ChainDetails, rhs: Nym_Vpn_ChainDetails) -> Bool {
    if lhs.bech32AccountPrefix != rhs.bech32AccountPrefix {return false}
    if lhs._mixDenom != rhs._mixDenom {return false}
    if lhs._stakeDenom != rhs._stakeDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymContracts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymContracts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mixnet_contract_address"),
    2: .standard(proto: "vesting_contract_address"),
    3: .standard(proto: "ecash_contract_address"),
    4: .standard(proto: "group_contract_address"),
    5: .standard(proto: "multisig_contract_address"),
    6: .standard(proto: "coconut_dkg_contract_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mixnetContractAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._vestingContractAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._ecashContractAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._groupContractAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._multisigContractAddress) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._coconutDkgContractAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mixnetContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._vestingContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ecashContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._groupContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._multisigContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._coconutDkgContractAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymContracts, rhs: Nym_Vpn_NymContracts) -> Bool {
    if lhs._mixnetContractAddress != rhs._mixnetContractAddress {return false}
    if lhs._vestingContractAddress != rhs._vestingContractAddress {return false}
    if lhs._ecashContractAddress != rhs._ecashContractAddress {return false}
    if lhs._groupContractAddress != rhs._groupContractAddress {return false}
    if lhs._multisigContractAddress != rhs._multisigContractAddress {return false}
    if lhs._coconutDkgContractAddress != rhs._coconutDkgContractAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymNetworkDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymNetworkDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "network_name"),
    2: .standard(proto: "chain_details"),
    3: .same(proto: "endpoints"),
    4: .same(proto: "contracts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.networkName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chainDetails) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._contracts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.networkName.isEmpty {
      try visitor.visitSingularStringField(value: self.networkName, fieldNumber: 1)
    }
    try { if let v = self._chainDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 3)
    }
    try { if let v = self._contracts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymNetworkDetails, rhs: Nym_Vpn_NymNetworkDetails) -> Bool {
    if lhs.networkName != rhs.networkName {return false}
    if lhs._chainDetails != rhs._chainDetails {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs._contracts != rhs._contracts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NymVpnNetworkDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NymVpnNetworkDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_vpn_api_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nymVpnApiURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nymVpnApiURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NymVpnNetworkDetails, rhs: Nym_Vpn_NymVpnNetworkDetails) -> Bool {
    if lhs._nymVpnApiURL != rhs._nymVpnApiURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AccountManagement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountManagement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sign_up"),
    2: .standard(proto: "sign_in"),
    3: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signUp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signUp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AccountManagement, rhs: Nym_Vpn_AccountManagement) -> Bool {
    if lhs._signUp != rhs._signUp {return false}
    if lhs._signIn != rhs._signIn {return false}
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ValidatorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nyxd_url"),
    2: .standard(proto: "websocket_url"),
    3: .standard(proto: "api_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nyxdURL) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._websocketURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._apiURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nyxdURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._websocketURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._apiURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ValidatorDetails, rhs: Nym_Vpn_ValidatorDetails) -> Bool {
    if lhs._nyxdURL != rhs._nyxdURL {return false}
    if lhs._websocketURL != rhs._websocketURL {return false}
    if lhs._apiURL != rhs._apiURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_InfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "build_timestamp"),
    3: .same(proto: "triple"),
    4: .same(proto: "platform"),
    5: .standard(proto: "git_commit"),
    6: .standard(proto: "nym_network"),
    7: .standard(proto: "nym_vpn_network"),
  ]

  fileprivate class _StorageClass {
    var _version: String = String()
    var _buildTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _triple: String = String()
    var _platform: String = String()
    var _gitCommit: String = String()
    var _nymNetwork: Nym_Vpn_NymNetworkDetails? = nil
    var _nymVpnNetwork: Nym_Vpn_NymVpnNetworkDetails? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _buildTimestamp = source._buildTimestamp
      _triple = source._triple
      _platform = source._platform
      _gitCommit = source._gitCommit
      _nymNetwork = source._nymNetwork
      _nymVpnNetwork = source._nymVpnNetwork
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._buildTimestamp) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._triple) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._platform) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._gitCommit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._nymNetwork) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._nymVpnNetwork) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 1)
      }
      try { if let v = _storage._buildTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._triple.isEmpty {
        try visitor.visitSingularStringField(value: _storage._triple, fieldNumber: 3)
      }
      if !_storage._platform.isEmpty {
        try visitor.visitSingularStringField(value: _storage._platform, fieldNumber: 4)
      }
      if !_storage._gitCommit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gitCommit, fieldNumber: 5)
      }
      try { if let v = _storage._nymNetwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._nymVpnNetwork {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_InfoResponse, rhs: Nym_Vpn_InfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._buildTimestamp != rhs_storage._buildTimestamp {return false}
        if _storage._triple != rhs_storage._triple {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._gitCommit != rhs_storage._gitCommit {return false}
        if _storage._nymNetwork != rhs_storage._nymNetwork {return false}
        if _storage._nymVpnNetwork != rhs_storage._nymVpnNetwork {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkRequest, rhs: Nym_Vpn_SetNetworkRequest) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkResponse, rhs: Nym_Vpn_SetNetworkResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequestError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetNetworkRequestError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SetNetworkRequestError, rhs: Nym_Vpn_SetNetworkRequestError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_SetNetworkRequestError.SetNetworkRequestErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SET_NETWORK_REQUEST_ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "INTERNAL"),
    2: .same(proto: "INVALID_NETWORK_NAME"),
  ]
}

extension Nym_Vpn_SystemMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SystemMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "message"),
    3: .same(proto: "properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.properties, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_SystemMessage, rhs: Nym_Vpn_SystemMessage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.message != rhs.message {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_NetworkCompatibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkCompatibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "core"),
    2: .same(proto: "ios"),
    3: .same(proto: "macos"),
    4: .same(proto: "tauri"),
    5: .same(proto: "android"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.core) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ios) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.macos) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tauri) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.android) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.core.isEmpty {
      try visitor.visitSingularStringField(value: self.core, fieldNumber: 1)
    }
    if !self.ios.isEmpty {
      try visitor.visitSingularStringField(value: self.ios, fieldNumber: 2)
    }
    if !self.macos.isEmpty {
      try visitor.visitSingularStringField(value: self.macos, fieldNumber: 3)
    }
    if !self.tauri.isEmpty {
      try visitor.visitSingularStringField(value: self.tauri, fieldNumber: 4)
    }
    if !self.android.isEmpty {
      try visitor.visitSingularStringField(value: self.android, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_NetworkCompatibility, rhs: Nym_Vpn_NetworkCompatibility) -> Bool {
    if lhs.core != rhs.core {return false}
    if lhs.ios != rhs.ios {return false}
    if lhs.macos != rhs.macos {return false}
    if lhs.tauri != rhs.tauri {return false}
    if lhs.android != rhs.android {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetSystemMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSystemMessagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetSystemMessagesResponse, rhs: Nym_Vpn_GetSystemMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetNetworkCompatibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetNetworkCompatibilityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messages {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetNetworkCompatibilityResponse, rhs: Nym_Vpn_GetNetworkCompatibilityResponse) -> Bool {
    if lhs._messages != rhs._messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetFeatureFlagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFeatureFlagsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .same(proto: "groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.flags) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Nym_Vpn_FeatureFlagGroup>.self, value: &self.groups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.flags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.flags, fieldNumber: 1)
    }
    if !self.groups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Nym_Vpn_FeatureFlagGroup>.self, value: self.groups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetFeatureFlagsResponse, rhs: Nym_Vpn_GetFeatureFlagsResponse) -> Bool {
    if lhs.flags != rhs.flags {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_FeatureFlagGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeatureFlagGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "map"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_FeatureFlagGroup, rhs: Nym_Vpn_FeatureFlagGroup) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Threshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Threshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.minPerformance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPerformance != 0 {
      try visitor.visitSingularUInt32Field(value: self.minPerformance, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Threshold, rhs: Nym_Vpn_Threshold) -> Bool {
    if lhs.minPerformance != rhs.minPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectRequestError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequestError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectRequestError, rhs: Nym_Vpn_ConnectRequestError) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectRequestError.ConnectRequestErrorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECT_REQUEST_ERROR_TYPE_UNSPECIFIED"),
    1: .same(proto: "INTERNAL"),
  ]
}

extension Nym_Vpn_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
    2: .same(proto: "exit"),
    3: .same(proto: "dns"),
    4: .standard(proto: "disable_routing"),
    5: .standard(proto: "enable_two_hop"),
    13: .same(proto: "netstack"),
    6: .standard(proto: "disable_poisson_rate"),
    7: .standard(proto: "disable_background_cover_traffic"),
    8: .standard(proto: "enable_credentials_mode"),
    12: .standard(proto: "user_agent"),
    9: .standard(proto: "min_mixnode_performance"),
    10: .standard(proto: "min_gateway_mixnet_performance"),
    11: .standard(proto: "min_gateway_vpn_performance"),
  ]

  fileprivate class _StorageClass {
    var _entry: Nym_Vpn_EntryNode? = nil
    var _exit: Nym_Vpn_ExitNode? = nil
    var _dns: Nym_Vpn_Dns? = nil
    var _disableRouting: Bool = false
    var _enableTwoHop: Bool = false
    var _netstack: Bool = false
    var _disablePoissonRate: Bool = false
    var _disableBackgroundCoverTraffic: Bool = false
    var _enableCredentialsMode: Bool = false
    var _userAgent: Nym_Vpn_UserAgent? = nil
    var _minMixnodePerformance: Nym_Vpn_Threshold? = nil
    var _minGatewayMixnetPerformance: Nym_Vpn_Threshold? = nil
    var _minGatewayVpnPerformance: Nym_Vpn_Threshold? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _entry = source._entry
      _exit = source._exit
      _dns = source._dns
      _disableRouting = source._disableRouting
      _enableTwoHop = source._enableTwoHop
      _netstack = source._netstack
      _disablePoissonRate = source._disablePoissonRate
      _disableBackgroundCoverTraffic = source._disableBackgroundCoverTraffic
      _enableCredentialsMode = source._enableCredentialsMode
      _userAgent = source._userAgent
      _minMixnodePerformance = source._minMixnodePerformance
      _minGatewayMixnetPerformance = source._minGatewayMixnetPerformance
      _minGatewayVpnPerformance = source._minGatewayVpnPerformance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._entry) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._exit) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dns) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._disableRouting) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._enableTwoHop) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._disablePoissonRate) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._disableBackgroundCoverTraffic) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._enableCredentialsMode) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._minMixnodePerformance) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._minGatewayMixnetPerformance) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._minGatewayVpnPerformance) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._userAgent) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._netstack) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._entry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._exit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dns {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._disableRouting != false {
        try visitor.visitSingularBoolField(value: _storage._disableRouting, fieldNumber: 4)
      }
      if _storage._enableTwoHop != false {
        try visitor.visitSingularBoolField(value: _storage._enableTwoHop, fieldNumber: 5)
      }
      if _storage._disablePoissonRate != false {
        try visitor.visitSingularBoolField(value: _storage._disablePoissonRate, fieldNumber: 6)
      }
      if _storage._disableBackgroundCoverTraffic != false {
        try visitor.visitSingularBoolField(value: _storage._disableBackgroundCoverTraffic, fieldNumber: 7)
      }
      if _storage._enableCredentialsMode != false {
        try visitor.visitSingularBoolField(value: _storage._enableCredentialsMode, fieldNumber: 8)
      }
      try { if let v = _storage._minMixnodePerformance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._minGatewayMixnetPerformance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._minGatewayVpnPerformance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._userAgent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._netstack != false {
        try visitor.visitSingularBoolField(value: _storage._netstack, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectRequest, rhs: Nym_Vpn_ConnectRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entry != rhs_storage._entry {return false}
        if _storage._exit != rhs_storage._exit {return false}
        if _storage._dns != rhs_storage._dns {return false}
        if _storage._disableRouting != rhs_storage._disableRouting {return false}
        if _storage._enableTwoHop != rhs_storage._enableTwoHop {return false}
        if _storage._netstack != rhs_storage._netstack {return false}
        if _storage._disablePoissonRate != rhs_storage._disablePoissonRate {return false}
        if _storage._disableBackgroundCoverTraffic != rhs_storage._disableBackgroundCoverTraffic {return false}
        if _storage._enableCredentialsMode != rhs_storage._enableCredentialsMode {return false}
        if _storage._userAgent != rhs_storage._userAgent {return false}
        if _storage._minMixnodePerformance != rhs_storage._minMixnodePerformance {return false}
        if _storage._minGatewayMixnetPerformance != rhs_storage._minGatewayMixnetPerformance {return false}
        if _storage._minGatewayVpnPerformance != rhs_storage._minGatewayVpnPerformance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectResponse, rhs: Nym_Vpn_ConnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_DisconnectResponse, rhs: Nym_Vpn_DisconnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_connect"),
    2: .standard(proto: "can_route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canConnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canRoute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canConnect != false {
      try visitor.visitSingularBoolField(value: self.canConnect, fieldNumber: 1)
    }
    if self.canRoute != false {
      try visitor.visitSingularBoolField(value: self.canRoute, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AsEntry, rhs: Nym_Vpn_AsEntry) -> Bool {
    if lhs.canConnect != rhs.canConnect {return false}
    if lhs.canRoute != rhs.canRoute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_AsExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsExit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_connect"),
    2: .standard(proto: "can_route_ip_v4"),
    3: .standard(proto: "can_route_ip_v6"),
    4: .standard(proto: "can_route_ip_external_v4"),
    5: .standard(proto: "can_route_ip_external_v6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canConnect) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpV4) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpV6) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpExternalV4) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.canRouteIpExternalV6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canConnect != false {
      try visitor.visitSingularBoolField(value: self.canConnect, fieldNumber: 1)
    }
    if self.canRouteIpV4 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpV4, fieldNumber: 2)
    }
    if self.canRouteIpV6 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpV6, fieldNumber: 3)
    }
    if self.canRouteIpExternalV4 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpExternalV4, fieldNumber: 4)
    }
    if self.canRouteIpExternalV6 != false {
      try visitor.visitSingularBoolField(value: self.canRouteIpExternalV6, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_AsExit, rhs: Nym_Vpn_AsExit) -> Bool {
    if lhs.canConnect != rhs.canConnect {return false}
    if lhs.canRouteIpV4 != rhs.canRouteIpV4 {return false}
    if lhs.canRouteIpV6 != rhs.canRouteIpV6 {return false}
    if lhs.canRouteIpExternalV4 != rhs.canRouteIpExternalV4 {return false}
    if lhs.canRouteIpExternalV6 != rhs.canRouteIpExternalV6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WgProbeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WgProbeResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "can_register"),
    2: .standard(proto: "can_handshake"),
    3: .standard(proto: "can_resolve_dns"),
    4: .standard(proto: "ping_hosts_performance"),
    5: .standard(proto: "ping_ips_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canRegister) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canHandshake) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canResolveDns) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.pingHostsPerformance) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.pingIpsPerformance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canRegister != false {
      try visitor.visitSingularBoolField(value: self.canRegister, fieldNumber: 1)
    }
    if self.canHandshake != false {
      try visitor.visitSingularBoolField(value: self.canHandshake, fieldNumber: 2)
    }
    if self.canResolveDns != false {
      try visitor.visitSingularBoolField(value: self.canResolveDns, fieldNumber: 3)
    }
    if self.pingHostsPerformance.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.pingHostsPerformance, fieldNumber: 4)
    }
    if self.pingIpsPerformance.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.pingIpsPerformance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WgProbeResult, rhs: Nym_Vpn_WgProbeResult) -> Bool {
    if lhs.canRegister != rhs.canRegister {return false}
    if lhs.canHandshake != rhs.canHandshake {return false}
    if lhs.canResolveDns != rhs.canResolveDns {return false}
    if lhs.pingHostsPerformance != rhs.pingHostsPerformance {return false}
    if lhs.pingIpsPerformance != rhs.pingIpsPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ProbeOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProbeOutcome"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "as_entry"),
    2: .standard(proto: "as_exit"),
    3: .same(proto: "wg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asEntry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asExit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._wg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._asExit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._wg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ProbeOutcome, rhs: Nym_Vpn_ProbeOutcome) -> Bool {
    if lhs._asEntry != rhs._asEntry {return false}
    if lhs._asExit != rhs._asExit {return false}
    if lhs._wg != rhs._wg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_Probe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Probe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_updated_utc"),
    2: .same(proto: "outcome"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastUpdatedUtc) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastUpdatedUtc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_Probe, rhs: Nym_Vpn_Probe) -> Bool {
    if lhs._lastUpdatedUtc != rhs._lastUpdatedUtc {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GatewayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GatewayResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "location"),
    3: .standard(proto: "last_probe"),
    4: .standard(proto: "wg_score"),
    5: .standard(proto: "mixnet_score"),
    6: .same(proto: "moniker"),
  ]

  fileprivate class _StorageClass {
    var _id: Nym_Vpn_Gateway? = nil
    var _location: Nym_Vpn_Location? = nil
    var _lastProbe: Nym_Vpn_Probe? = nil
    var _wgScore: Nym_Vpn_Score? = nil
    var _mixnetScore: Nym_Vpn_Score? = nil
    var _moniker: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _location = source._location
      _lastProbe = source._lastProbe
      _wgScore = source._wgScore
      _mixnetScore = source._mixnetScore
      _moniker = source._moniker
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._lastProbe) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._wgScore) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._mixnetScore) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._moniker) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._lastProbe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._wgScore {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._mixnetScore {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      if !_storage._moniker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moniker, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GatewayResponse, rhs: Nym_Vpn_GatewayResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._lastProbe != rhs_storage._lastProbe {return false}
        if _storage._wgScore != rhs_storage._wgScore {return false}
        if _storage._mixnetScore != rhs_storage._mixnetScore {return false}
        if _storage._moniker != rhs_storage._moniker {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListGatewaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGatewaysRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    4: .standard(proto: "user_agent"),
    2: .standard(proto: "min_mixnet_performance"),
    3: .standard(proto: "min_vpn_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minMixnetPerformance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minVpnPerformance) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._minMixnetPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minVpnPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._userAgent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListGatewaysRequest, rhs: Nym_Vpn_ListGatewaysRequest) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs._minMixnetPerformance != rhs._minMixnetPerformance {return false}
    if lhs._minVpnPerformance != rhs._minVpnPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListGatewaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListGatewaysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateways"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gateways) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gateways.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gateways, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListGatewaysResponse, rhs: Nym_Vpn_ListGatewaysResponse) -> Bool {
    if lhs.gateways != rhs.gateways {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListCountriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListCountriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    4: .standard(proto: "user_agent"),
    2: .standard(proto: "min_mixnet_performance"),
    3: .standard(proto: "min_vpn_performance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minMixnetPerformance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minVpnPerformance) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._minMixnetPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minVpnPerformance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._userAgent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListCountriesRequest, rhs: Nym_Vpn_ListCountriesRequest) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs._minMixnetPerformance != rhs._minMixnetPerformance {return false}
    if lhs._minVpnPerformance != rhs._minVpnPerformance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ListCountriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListCountriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.countries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.countries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ListCountriesResponse, rhs: Nym_Vpn_ListCountriesResponse) -> Bool {
    if lhs.countries != rhs.countries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountLinksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountLinksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.locale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locale.isEmpty {
      try visitor.visitSingularStringField(value: self.locale, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountLinksRequest, rhs: Nym_Vpn_GetAccountLinksRequest) -> Bool {
    if lhs.locale != rhs.locale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_GetAccountLinksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountLinksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_AccountManagement?
        var hadOneofValue = false
        if let current = self.res {
          hadOneofValue = true
          if case .links(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.res = .links(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_AccountError?
        var hadOneofValue = false
        if let current = self.res {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.res = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.res {
    case .links?: try {
      guard case .links(let v)? = self.res else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.res else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_GetAccountLinksResponse, rhs: Nym_Vpn_GetAccountLinksResponse) -> Bool {
    if lhs.res != rhs.res {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_ConnectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_gateway"),
    2: .standard(proto: "exit_gateway"),
    3: .standard(proto: "connected_at"),
    4: .same(proto: "tunnel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entryGateway) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitGateway) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._connectedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tunnel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entryGateway {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitGateway {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._connectedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tunnel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_ConnectionData, rhs: Nym_Vpn_ConnectionData) -> Bool {
    if lhs._entryGateway != rhs._entryGateway {return false}
    if lhs._exitGateway != rhs._exitGateway {return false}
    if lhs._connectedAt != rhs._connectedAt {return false}
    if lhs._tunnel != rhs._tunnel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixnetConnectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MixnetConnectionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "nym_address"),
    2: .standard(proto: "exit_ipr"),
    3: .same(proto: "ipv4"),
    4: .same(proto: "ipv6"),
    5: .standard(proto: "entry_ip"),
    6: .standard(proto: "exit_ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nymAddress) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exitIpr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipv4) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipv6) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.entryIp) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.exitIp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nymAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exitIpr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ipv4.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv4, fieldNumber: 3)
    }
    if !self.ipv6.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv6, fieldNumber: 4)
    }
    if !self.entryIp.isEmpty {
      try visitor.visitSingularStringField(value: self.entryIp, fieldNumber: 5)
    }
    if !self.exitIp.isEmpty {
      try visitor.visitSingularStringField(value: self.exitIp, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixnetConnectionData, rhs: Nym_Vpn_MixnetConnectionData) -> Bool {
    if lhs._nymAddress != rhs._nymAddress {return false}
    if lhs._exitIpr != rhs._exitIpr {return false}
    if lhs.ipv4 != rhs.ipv4 {return false}
    if lhs.ipv6 != rhs.ipv6 {return false}
    if lhs.entryIp != rhs.entryIp {return false}
    if lhs.exitIp != rhs.exitIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WireguardConnectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WireguardConnectionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
    2: .same(proto: "exit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._exit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._entry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WireguardConnectionData, rhs: Nym_Vpn_WireguardConnectionData) -> Bool {
    if lhs._entry != rhs._entry {return false}
    if lhs._exit != rhs._exit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_WireguardNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WireguardNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoint"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "private_ipv4"),
    4: .standard(proto: "private_ipv6"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.privateIpv4) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.privateIpv6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 2)
    }
    if !self.privateIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.privateIpv4, fieldNumber: 3)
    }
    if !self.privateIpv6.isEmpty {
      try visitor.visitSingularStringField(value: self.privateIpv6, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_WireguardNode, rhs: Nym_Vpn_WireguardNode) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.privateIpv4 != rhs.privateIpv4 {return false}
    if lhs.privateIpv6 != rhs.privateIpv6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelConnectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TunnelConnectionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mixnet"),
    2: .same(proto: "wireguard"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_TunnelConnectionData.Mixnet?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .mixnet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .mixnet(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_TunnelConnectionData.Wireguard?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .wireguard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .wireguard(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.state {
    case .mixnet?: try {
      guard case .mixnet(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wireguard?: try {
      guard case .wireguard(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelConnectionData, rhs: Nym_Vpn_TunnelConnectionData) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelConnectionData.Mixnet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_TunnelConnectionData.protoMessageName + ".Mixnet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelConnectionData.Mixnet, rhs: Nym_Vpn_TunnelConnectionData.Mixnet) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelConnectionData.Wireguard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_TunnelConnectionData.protoMessageName + ".Wireguard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelConnectionData.Wireguard, rhs: Nym_Vpn_TunnelConnectionData.Wireguard) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TunnelState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disconnected"),
    2: .same(proto: "connecting"),
    3: .same(proto: "connected"),
    4: .same(proto: "disconnecting"),
    5: .same(proto: "error"),
    6: .same(proto: "offline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_TunnelState.Disconnected?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .disconnected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .disconnected(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_TunnelState.Connecting?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .connecting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .connecting(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_TunnelState.Connected?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .connected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .connected(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_TunnelState.Disconnecting?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .disconnecting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .disconnecting(v)
        }
      }()
      case 5: try {
        var v: Nym_Vpn_TunnelState.Error?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .error(v)
        }
      }()
      case 6: try {
        var v: Nym_Vpn_TunnelState.Offline?
        var hadOneofValue = false
        if let current = self.state {
          hadOneofValue = true
          if case .offline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.state = .offline(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.state {
    case .disconnected?: try {
      guard case .disconnected(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .connecting?: try {
      guard case .connecting(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .connected?: try {
      guard case .connected(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .disconnecting?: try {
      guard case .disconnecting(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .error?: try {
      guard case .error(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .offline?: try {
      guard case .offline(let v)? = self.state else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelState, rhs: Nym_Vpn_TunnelState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelState.BaseErrorStateReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIREWALL"),
    1: .same(proto: "ROUTING"),
    2: .same(proto: "DNS"),
    3: .same(proto: "TUN_DEVICE"),
    4: .same(proto: "TUNNEL_PROVIDER"),
    5: .same(proto: "SAME_ENTRY_AND_EXIT_GATEWAY"),
    6: .same(proto: "INVALID_ENTRY_GATEWAY_COUNTRY"),
    7: .same(proto: "INVALID_EXIT_GATEWAY_COUNTRY"),
    8: .same(proto: "BAD_BANDWIDTH_INCREASE"),
    9: .same(proto: "DUPLICATE_TUN_FD"),
    10: .same(proto: "INTERNAL"),
    11: .same(proto: "RESOLVE_GATEWAY_ADDRS"),
    12: .same(proto: "START_LOCAL_DNS_RESOLVER"),
  ]
}

extension Nym_Vpn_TunnelState.ActionAfterDisconnect: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTHING"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "RECONNECT"),
    3: .same(proto: "OFFLINE"),
  ]
}

extension Nym_Vpn_TunnelState.Disconnected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_TunnelState.protoMessageName + ".Disconnected"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelState.Disconnected, rhs: Nym_Vpn_TunnelState.Disconnected) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelState.Connecting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_TunnelState.protoMessageName + ".Connecting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connectionData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connectionData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelState.Connecting, rhs: Nym_Vpn_TunnelState.Connecting) -> Bool {
    if lhs._connectionData != rhs._connectionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelState.Connected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_TunnelState.protoMessageName + ".Connected"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connectionData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connectionData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelState.Connected, rhs: Nym_Vpn_TunnelState.Connected) -> Bool {
    if lhs._connectionData != rhs._connectionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelState.Disconnecting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_TunnelState.protoMessageName + ".Disconnecting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "after_disconnect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.afterDisconnect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.afterDisconnect != .nothing {
      try visitor.visitSingularEnumField(value: self.afterDisconnect, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelState.Disconnecting, rhs: Nym_Vpn_TunnelState.Disconnecting) -> Bool {
    if lhs.afterDisconnect != rhs.afterDisconnect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelState.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_TunnelState.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_reason"),
    2: .standard(proto: "sync_account"),
    3: .standard(proto: "sync_device"),
    4: .standard(proto: "register_device"),
    5: .standard(proto: "request_zk_nym"),
    6: .standard(proto: "request_zk_nym_bundle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_TunnelState.BaseErrorStateReason?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.errorStateReason != nil {try decoder.handleConflictingOneOf()}
          self.errorStateReason = .baseReason(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_SyncAccountError?
        var hadOneofValue = false
        if let current = self.errorStateReason {
          hadOneofValue = true
          if case .syncAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorStateReason = .syncAccount(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_SyncDeviceError?
        var hadOneofValue = false
        if let current = self.errorStateReason {
          hadOneofValue = true
          if case .syncDevice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorStateReason = .syncDevice(v)
        }
      }()
      case 4: try {
        var v: Nym_Vpn_RegisterDeviceError?
        var hadOneofValue = false
        if let current = self.errorStateReason {
          hadOneofValue = true
          if case .registerDevice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorStateReason = .registerDevice(v)
        }
      }()
      case 5: try {
        var v: Nym_Vpn_RequestZkNymError?
        var hadOneofValue = false
        if let current = self.errorStateReason {
          hadOneofValue = true
          if case .requestZkNym(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorStateReason = .requestZkNym(v)
        }
      }()
      case 6: try {
        var v: Nym_Vpn_RequestZkNymBundle?
        var hadOneofValue = false
        if let current = self.errorStateReason {
          hadOneofValue = true
          if case .requestZkNymBundle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.errorStateReason = .requestZkNymBundle(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.errorStateReason {
    case .baseReason?: try {
      guard case .baseReason(let v)? = self.errorStateReason else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .syncAccount?: try {
      guard case .syncAccount(let v)? = self.errorStateReason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .syncDevice?: try {
      guard case .syncDevice(let v)? = self.errorStateReason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .registerDevice?: try {
      guard case .registerDevice(let v)? = self.errorStateReason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .requestZkNym?: try {
      guard case .requestZkNym(let v)? = self.errorStateReason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .requestZkNymBundle?: try {
      guard case .requestZkNymBundle(let v)? = self.errorStateReason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelState.Error, rhs: Nym_Vpn_TunnelState.Error) -> Bool {
    if lhs.errorStateReason != rhs.errorStateReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelState.Offline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_TunnelState.protoMessageName + ".Offline"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reconnect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.reconnect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reconnect != false {
      try visitor.visitSingularBoolField(value: self.reconnect, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelState.Offline, rhs: Nym_Vpn_TunnelState.Offline) -> Bool {
    if lhs.reconnect != rhs.reconnect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_TunnelEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TunnelEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tunnel_state"),
    2: .standard(proto: "mixnet_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_TunnelState?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .tunnelState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .tunnelState(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_MixnetEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mixnetEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mixnetEvent(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .tunnelState?: try {
      guard case .tunnelState(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mixnetEvent?: try {
      guard case .mixnetEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_TunnelEvent, rhs: Nym_Vpn_TunnelEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixnetEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MixnetEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bandwidth_event"),
    2: .standard(proto: "connection_event"),
    3: .standard(proto: "connection_statistics_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_MixnetEvent.BandwidthEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bandwidthEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bandwidthEvent(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_MixnetEvent.ConnectionEvent?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .connectionEvent(v)
        }
      }()
      case 3: try {
        var v: Nym_Vpn_MixnetEvent.ConnectionStatisticsEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .connectionStatisticsEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .connectionStatisticsEvent(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .bandwidthEvent?: try {
      guard case .bandwidthEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .connectionEvent?: try {
      guard case .connectionEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .connectionStatisticsEvent?: try {
      guard case .connectionStatisticsEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixnetEvent, rhs: Nym_Vpn_MixnetEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixnetEvent.ConnectionEvent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENTRY_GATEWAY_DOWN"),
    1: .same(proto: "EXIT_GATEWAY_DOWN_IPV4"),
    2: .same(proto: "EXIT_GATEWAY_DOWN_IPV6"),
    3: .same(proto: "EXIT_GATEWAY_ROUTING_ERROR_IPV4"),
    4: .same(proto: "EXIT_GATEWAY_ROUTING_ERROR_IPV6"),
    5: .same(proto: "CONNECTED_IPV4"),
    6: .same(proto: "CONNECTED_IPV6"),
  ]
}

extension Nym_Vpn_MixnetEvent.BandwidthEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_MixnetEvent.protoMessageName + ".BandwidthEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "no_bandwidth"),
    2: .standard(proto: "remaining_bandwidth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Nym_Vpn_MixnetEvent.BandwidthEvent.NoBandwidth?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .noBandwidth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .noBandwidth(v)
        }
      }()
      case 2: try {
        var v: Nym_Vpn_MixnetEvent.BandwidthEvent.RemainingBandwidth?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .remainingBandwidth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .remainingBandwidth(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .noBandwidth?: try {
      guard case .noBandwidth(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .remainingBandwidth?: try {
      guard case .remainingBandwidth(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixnetEvent.BandwidthEvent, rhs: Nym_Vpn_MixnetEvent.BandwidthEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixnetEvent.BandwidthEvent.NoBandwidth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_MixnetEvent.BandwidthEvent.protoMessageName + ".NoBandwidth"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixnetEvent.BandwidthEvent.NoBandwidth, rhs: Nym_Vpn_MixnetEvent.BandwidthEvent.NoBandwidth) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixnetEvent.BandwidthEvent.RemainingBandwidth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_MixnetEvent.BandwidthEvent.protoMessageName + ".RemainingBandwidth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixnetEvent.BandwidthEvent.RemainingBandwidth, rhs: Nym_Vpn_MixnetEvent.BandwidthEvent.RemainingBandwidth) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixnetEvent.SphinxPacketRates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_MixnetEvent.protoMessageName + ".SphinxPacketRates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "real_packets_sent"),
    2: .standard(proto: "real_packets_sent_size"),
    3: .standard(proto: "cover_packets_sent"),
    4: .standard(proto: "cover_packets_sent_size"),
    5: .standard(proto: "real_packets_received"),
    6: .standard(proto: "real_packets_received_size"),
    7: .standard(proto: "cover_packets_received"),
    8: .standard(proto: "cover_packets_received_size"),
    9: .standard(proto: "total_acks_received"),
    10: .standard(proto: "total_acks_received_size"),
    11: .standard(proto: "real_acks_received"),
    12: .standard(proto: "real_acks_received_size"),
    13: .standard(proto: "cover_acks_received"),
    14: .standard(proto: "cover_acks_received_size"),
    15: .standard(proto: "real_packets_queued"),
    16: .standard(proto: "retransmissions_queued"),
    17: .standard(proto: "reply_surbs_queued"),
    18: .standard(proto: "additional_reply_surbs_queued"),
  ]

  fileprivate class _StorageClass {
    var _realPacketsSent: Double = 0
    var _realPacketsSentSize: Double = 0
    var _coverPacketsSent: Double = 0
    var _coverPacketsSentSize: Double = 0
    var _realPacketsReceived: Double = 0
    var _realPacketsReceivedSize: Double = 0
    var _coverPacketsReceived: Double = 0
    var _coverPacketsReceivedSize: Double = 0
    var _totalAcksReceived: Double = 0
    var _totalAcksReceivedSize: Double = 0
    var _realAcksReceived: Double = 0
    var _realAcksReceivedSize: Double = 0
    var _coverAcksReceived: Double = 0
    var _coverAcksReceivedSize: Double = 0
    var _realPacketsQueued: Double = 0
    var _retransmissionsQueued: Double = 0
    var _replySurbsQueued: Double = 0
    var _additionalReplySurbsQueued: Double = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _realPacketsSent = source._realPacketsSent
      _realPacketsSentSize = source._realPacketsSentSize
      _coverPacketsSent = source._coverPacketsSent
      _coverPacketsSentSize = source._coverPacketsSentSize
      _realPacketsReceived = source._realPacketsReceived
      _realPacketsReceivedSize = source._realPacketsReceivedSize
      _coverPacketsReceived = source._coverPacketsReceived
      _coverPacketsReceivedSize = source._coverPacketsReceivedSize
      _totalAcksReceived = source._totalAcksReceived
      _totalAcksReceivedSize = source._totalAcksReceivedSize
      _realAcksReceived = source._realAcksReceived
      _realAcksReceivedSize = source._realAcksReceivedSize
      _coverAcksReceived = source._coverAcksReceived
      _coverAcksReceivedSize = source._coverAcksReceivedSize
      _realPacketsQueued = source._realPacketsQueued
      _retransmissionsQueued = source._retransmissionsQueued
      _replySurbsQueued = source._replySurbsQueued
      _additionalReplySurbsQueued = source._additionalReplySurbsQueued
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularDoubleField(value: &_storage._realPacketsSent) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._realPacketsSentSize) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._coverPacketsSent) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._coverPacketsSentSize) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._realPacketsReceived) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._realPacketsReceivedSize) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._coverPacketsReceived) }()
        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._coverPacketsReceivedSize) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._totalAcksReceived) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._totalAcksReceivedSize) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._realAcksReceived) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._realAcksReceivedSize) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._coverAcksReceived) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._coverAcksReceivedSize) }()
        case 15: try { try decoder.decodeSingularDoubleField(value: &_storage._realPacketsQueued) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._retransmissionsQueued) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._replySurbsQueued) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._additionalReplySurbsQueued) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._realPacketsSent.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._realPacketsSent, fieldNumber: 1)
      }
      if _storage._realPacketsSentSize.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._realPacketsSentSize, fieldNumber: 2)
      }
      if _storage._coverPacketsSent.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._coverPacketsSent, fieldNumber: 3)
      }
      if _storage._coverPacketsSentSize.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._coverPacketsSentSize, fieldNumber: 4)
      }
      if _storage._realPacketsReceived.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._realPacketsReceived, fieldNumber: 5)
      }
      if _storage._realPacketsReceivedSize.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._realPacketsReceivedSize, fieldNumber: 6)
      }
      if _storage._coverPacketsReceived.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._coverPacketsReceived, fieldNumber: 7)
      }
      if _storage._coverPacketsReceivedSize.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._coverPacketsReceivedSize, fieldNumber: 8)
      }
      if _storage._totalAcksReceived.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._totalAcksReceived, fieldNumber: 9)
      }
      if _storage._totalAcksReceivedSize.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._totalAcksReceivedSize, fieldNumber: 10)
      }
      if _storage._realAcksReceived.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._realAcksReceived, fieldNumber: 11)
      }
      if _storage._realAcksReceivedSize.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._realAcksReceivedSize, fieldNumber: 12)
      }
      if _storage._coverAcksReceived.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._coverAcksReceived, fieldNumber: 13)
      }
      if _storage._coverAcksReceivedSize.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._coverAcksReceivedSize, fieldNumber: 14)
      }
      if _storage._realPacketsQueued.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._realPacketsQueued, fieldNumber: 15)
      }
      if _storage._retransmissionsQueued.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._retransmissionsQueued, fieldNumber: 16)
      }
      if _storage._replySurbsQueued.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._replySurbsQueued, fieldNumber: 17)
      }
      if _storage._additionalReplySurbsQueued.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._additionalReplySurbsQueued, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixnetEvent.SphinxPacketRates, rhs: Nym_Vpn_MixnetEvent.SphinxPacketRates) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._realPacketsSent != rhs_storage._realPacketsSent {return false}
        if _storage._realPacketsSentSize != rhs_storage._realPacketsSentSize {return false}
        if _storage._coverPacketsSent != rhs_storage._coverPacketsSent {return false}
        if _storage._coverPacketsSentSize != rhs_storage._coverPacketsSentSize {return false}
        if _storage._realPacketsReceived != rhs_storage._realPacketsReceived {return false}
        if _storage._realPacketsReceivedSize != rhs_storage._realPacketsReceivedSize {return false}
        if _storage._coverPacketsReceived != rhs_storage._coverPacketsReceived {return false}
        if _storage._coverPacketsReceivedSize != rhs_storage._coverPacketsReceivedSize {return false}
        if _storage._totalAcksReceived != rhs_storage._totalAcksReceived {return false}
        if _storage._totalAcksReceivedSize != rhs_storage._totalAcksReceivedSize {return false}
        if _storage._realAcksReceived != rhs_storage._realAcksReceived {return false}
        if _storage._realAcksReceivedSize != rhs_storage._realAcksReceivedSize {return false}
        if _storage._coverAcksReceived != rhs_storage._coverAcksReceived {return false}
        if _storage._coverAcksReceivedSize != rhs_storage._coverAcksReceivedSize {return false}
        if _storage._realPacketsQueued != rhs_storage._realPacketsQueued {return false}
        if _storage._retransmissionsQueued != rhs_storage._retransmissionsQueued {return false}
        if _storage._replySurbsQueued != rhs_storage._replySurbsQueued {return false}
        if _storage._additionalReplySurbsQueued != rhs_storage._additionalReplySurbsQueued {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nym_Vpn_MixnetEvent.ConnectionStatisticsEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Nym_Vpn_MixnetEvent.protoMessageName + ".ConnectionStatisticsEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nym_Vpn_MixnetEvent.ConnectionStatisticsEvent, rhs: Nym_Vpn_MixnetEvent.ConnectionStatisticsEvent) -> Bool {
    if lhs._rates != rhs._rates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
